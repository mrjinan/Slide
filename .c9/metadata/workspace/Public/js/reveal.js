{"filter":false,"title":"reveal.js","tooltip":"/Public/js/reveal.js","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":799,"column":53},"action":"remove","lines":["/**"," * impress.js"," *"," * impress.js is a presentation tool based on the power of CSS3 transforms and transitions"," * in modern browsers and inspired by the idea behind prezi.com."," *"," *"," * Copyright 2011-2012 Bartek Szopka (@bartaz)"," *"," * Released under the MIT and GPL Licenses."," *"," * ------------------------------------------------"," *  author:  Bartek Szopka"," *  version: 0.5.3"," *  url:     http://bartaz.github.com/impress.js/"," *  source:  http://github.com/bartaz/impress.js/"," */","","/*jshint bitwise:true, curly:true, eqeqeq:true, forin:true, latedef:true, newcap:true,","         noarg:true, noempty:true, undef:true, strict:true, browser:true */","","// You are one of those who like to know how thing work inside?","// Let me show you the cogs that make impress.js run...","(function ( document, window ) {","    'use strict';","    ","    // HELPER FUNCTIONS","    ","    // `pfx` is a function that takes a standard CSS property name as a parameter","    // and returns it's prefixed version valid for current browser it runs in.","    // The code is heavily inspired by Modernizr http://www.modernizr.com/","    var pfx = (function () {","        ","        var style = document.createElement('dummy').style,","            prefixes = 'Webkit Moz O ms Khtml'.split(' '),","            memory = {};","        ","        return function ( prop ) {","            if ( typeof memory[ prop ] === \"undefined\" ) {","                ","                var ucProp  = prop.charAt(0).toUpperCase() + prop.substr(1),","                    props   = (prop + ' ' + prefixes.join(ucProp + ' ') + ucProp).split(' ');","                ","                memory[ prop ] = null;","                for ( var i in props ) {","                    if ( style[ props[i] ] !== undefined ) {","                        memory[ prop ] = props[i];","                        break;","                    }","                }","            ","            }","            ","            return memory[ prop ];","        };","    ","    })();","    ","    // `arraify` takes an array-like object and turns it into real Array","    // to make all the Array.prototype goodness available.","    var arrayify = function ( a ) {","        return [].slice.call( a );","    };","    ","    // `css` function applies the styles given in `props` object to the element","    // given as `el`. It runs all property names through `pfx` function to make","    // sure proper prefixed version of the property is used.","    var css = function ( el, props ) {","        var key, pkey;","        for ( key in props ) {","            if ( props.hasOwnProperty(key) ) {","                pkey = pfx(key);","                if ( pkey !== null ) {","                    el.style[pkey] = props[key];","                }","            }","        }","        return el;","    };","    ","    // `toNumber` takes a value given as `numeric` parameter and tries to turn","    // it into a number. If it is not possible it returns 0 (or other value","    // given as `fallback`).","    var toNumber = function (numeric, fallback) {","        return isNaN(numeric) ? (fallback || 0) : Number(numeric);","    };","    ","    // `byId` returns element with given `id` - you probably have guessed that ;)","    var byId = function ( id ) {","        return document.getElementById(id);","    };","    ","    // `$` returns first element for given CSS `selector` in the `context` of","    // the given element or whole document.","    var $ = function ( selector, context ) {","        context = context || document;","        return context.querySelector(selector);","    };","    ","    // `$$` return an array of elements for given CSS `selector` in the `context` of","    // the given element or whole document.","    var $$ = function ( selector, context ) {","        context = context || document;","        return arrayify( context.querySelectorAll(selector) );","    };","    ","    // `triggerEvent` builds a custom DOM event with given `eventName` and `detail` data","    // and triggers it on element given as `el`.","    var triggerEvent = function (el, eventName, detail) {","        var event = document.createEvent(\"CustomEvent\");","        event.initCustomEvent(eventName, true, true, detail);","        el.dispatchEvent(event);","    };","    ","    // `translate` builds a translate transform string for given data.","    var translate = function ( t ) {","        return \" translate3d(\" + t.x + \"px,\" + t.y + \"px,\" + t.z + \"px) \";","    };","    ","    // `rotate` builds a rotate transform string for given data.","    // By default the rotations are in X Y Z order that can be reverted by passing `true`","    // as second parameter.","    var rotate = function ( r, revert ) {","        var rX = \" rotateX(\" + r.x + \"deg) \",","            rY = \" rotateY(\" + r.y + \"deg) \",","            rZ = \" rotateZ(\" + r.z + \"deg) \";","        ","        return revert ? rZ+rY+rX : rX+rY+rZ;","    };","    ","    // `scale` builds a scale transform string for given data.","    var scale = function ( s ) {","        return \" scale(\" + s + \") \";","    };","    ","    // `perspective` builds a perspective transform string for given data.","    var perspective = function ( p ) {","        return \" perspective(\" + p + \"px) \";","    };","    ","    // `getElementFromHash` returns an element located by id from hash part of","    // window location.","    var getElementFromHash = function () {","        // get id from url # by removing `#` or `#/` from the beginning,","        // so both \"fallback\" `#slide-id` and \"enhanced\" `#/slide-id` will work","        return byId( window.location.hash.replace(/^#\\/?/,\"\") );","    };","    ","    // `computeWindowScale` counts the scale factor between window size and size","    // defined for the presentation in the config.","    var computeWindowScale = function ( config ) {","        var hScale = window.innerHeight / config.height,","            wScale = window.innerWidth / config.width,","            scale = hScale > wScale ? wScale : hScale;","        ","        if (config.maxScale && scale > config.maxScale) {","            scale = config.maxScale;","        }","        ","        if (config.minScale && scale < config.minScale) {","            scale = config.minScale;","        }","        ","        return scale;","    };","    ","    // CHECK SUPPORT","    var body = document.body;","    ","    var ua = navigator.userAgent.toLowerCase();","    var impressSupported = ","                          // browser should support CSS 3D transtorms ","                           ( pfx(\"perspective\") !== null ) &&","                           ","                          // and `classList` and `dataset` APIs","                           ( body.classList ) &&","                           ( body.dataset ) &&","                           ","                          // but some mobile devices need to be blacklisted,","                          // because their CSS 3D support or hardware is not","                          // good enough to run impress.js properly, sorry...","                           ( ua.search(/(iphone)|(ipod)|(android)/) === -1 );","    ","    if (!impressSupported) {","        // we can't be sure that `classList` is supported","        body.className += \" impress-not-supported \";","    } else {","        body.classList.remove(\"impress-not-supported\");","        body.classList.add(\"impress-supported\");","    }","    ","    // GLOBALS AND DEFAULTS","    ","    // This is were the root elements of all impress.js instances will be kept.","    // Yes, this means you can have more than one instance on a page, but I'm not","    // sure if it makes any sense in practice ;)","    var roots = {};","    ","    // some default config values.","    var defaults = {","        width: 1024,","        height: 768,","        maxScale: 1,","        minScale: 0,","        ","        perspective: 1000,","        ","        transitionDuration: 1000","    };","    ","    // it's just an empty function ... and a useless comment.","    var empty = function () { return false; };","    ","    // IMPRESS.JS API","    ","    // And that's where interesting things will start to happen.","    // It's the core `impress` function that returns the impress.js API","    // for a presentation based on the element with given id ('impress'","    // by default).","    var impress = window.impress = function ( rootId ) {","        ","        // If impress.js is not supported by the browser return a dummy API","        // it may not be a perfect solution but we return early and avoid","        // running code that may use features not implemented in the browser.","        if (!impressSupported) {","            return {","                init: empty,","                goto: empty,","                prev: empty,","                next: empty","            };","        }","        ","        rootId = rootId || \"impress\";","        ","        // if given root is already initialized just return the API","        if (roots[\"impress-root-\" + rootId]) {","            return roots[\"impress-root-\" + rootId];","        }","        ","        // data of all presentation steps","        var stepsData = {};","        ","        // element of currently active step","        var activeStep = null;","        ","        // current state (position, rotation and scale) of the presentation","        var currentState = null;","        ","        // array of step elements","        var steps = null;","        ","        // configuration options","        var config = null;","        ","        // scale factor of the browser window","        var windowScale = null;        ","        ","        // root presentation elements","        var root = byId( rootId );","        var canvas = document.createElement(\"div\");","        ","        var initialized = false;","        ","        // STEP EVENTS","        //","        // There are currently two step events triggered by impress.js","        // `impress:stepenter` is triggered when the step is shown on the ","        // screen (the transition from the previous one is finished) and","        // `impress:stepleave` is triggered when the step is left (the","        // transition to next step just starts).","        ","        // reference to last entered step","        var lastEntered = null;","        ","        // `onStepEnter` is called whenever the step element is entered","        // but the event is triggered only if the step is different than","        // last entered step.","        var onStepEnter = function (step) {","            if (lastEntered !== step) {","                triggerEvent(step, \"impress:stepenter\");","                lastEntered = step;","            }","        };","        ","        // `onStepLeave` is called whenever the step element is left","        // but the event is triggered only if the step is the same as","        // last entered step.","        var onStepLeave = function (step) {","            if (lastEntered === step) {","                triggerEvent(step, \"impress:stepleave\");","                lastEntered = null;","            }","        };","        ","        // `initStep` initializes given step element by reading data from its","        // data attributes and setting correct styles.","        var initStep = function ( el, idx ) {","            var data = el.dataset,","                step = {","                    translate: {","                        x: toNumber(data.x),","                        y: toNumber(data.y),","                        z: toNumber(data.z)","                    },","                    rotate: {","                        x: toNumber(data.rotateX),","                        y: toNumber(data.rotateY),","                        z: toNumber(data.rotateZ || data.rotate)","                    },","                    scale: toNumber(data.scale, 1),","                    el: el","                };","            ","            if ( !el.id ) {","                el.id = \"step-\" + (idx + 1);","            }","            ","            stepsData[\"impress-\" + el.id] = step;","            ","            css(el, {","                position: \"absolute\",","                transform: \"translate(-50%,-50%)\" +","                           translate(step.translate) +","                           rotate(step.rotate) +","                           scale(step.scale),","                transformStyle: \"preserve-3d\"","            });","        };","        ","        // `init` API function that initializes (and runs) the presentation.","        var init = function () {","            if (initialized) { return; }","            ","            // First we set up the viewport for mobile devices.","            // For some reason iPad goes nuts when it is not done properly.","            var meta = $(\"meta[name='viewport']\") || document.createElement(\"meta\");","            meta.content = \"width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no\";","            if (meta.parentNode !== document.head) {","                meta.name = 'viewport';","                document.head.appendChild(meta);","            }","            ","            // initialize configuration object","            var rootData = root.dataset;","            config = {","                width: toNumber( rootData.width, defaults.width ),","                height: toNumber( rootData.height, defaults.height ),","                maxScale: toNumber( rootData.maxScale, defaults.maxScale ),","                minScale: toNumber( rootData.minScale, defaults.minScale ),                ","                perspective: toNumber( rootData.perspective, defaults.perspective ),","                transitionDuration: toNumber( rootData.transitionDuration, defaults.transitionDuration )","            };","            ","            windowScale = computeWindowScale( config );","            ","            // wrap steps with \"canvas\" element","            arrayify( root.childNodes ).forEach(function ( el ) {","                canvas.appendChild( el );","            });","            root.appendChild(canvas);","            ","            // set initial styles","            document.documentElement.style.height = \"100%\";","            ","            css(body, {","                height: \"100%\",","                overflow: \"hidden\"","            });","            ","            var rootStyles = {","                position: \"absolute\",","                transformOrigin: \"top left\",","                transition: \"all 0s ease-in-out\",","                transformStyle: \"preserve-3d\"","            };","            ","            css(root, rootStyles);","            css(root, {","                top: \"50%\",","                left: \"50%\",","                transform: perspective( config.perspective/windowScale ) + scale( windowScale )","            });","            css(canvas, rootStyles);","            ","            body.classList.remove(\"impress-disabled\");","            body.classList.add(\"impress-enabled\");","            ","            // get and init steps","            steps = $$(\".step\", root);","            steps.forEach( initStep );","            ","            // set a default initial state of the canvas","            currentState = {","                translate: { x: 0, y: 0, z: 0 },","                rotate:    { x: 0, y: 0, z: 0 },","                scale:     1","            };","            ","            initialized = true;","            ","            triggerEvent(root, \"impress:init\", { api: roots[ \"impress-root-\" + rootId ] });","        };","        ","        // `getStep` is a helper function that returns a step element defined by parameter.","        // If a number is given, step with index given by the number is returned, if a string","        // is given step element with such id is returned, if DOM element is given it is returned","        // if it is a correct step element.","        var getStep = function ( step ) {","            if (typeof step === \"number\") {","                step = step < 0 ? steps[ steps.length + step] : steps[ step ];","            } else if (typeof step === \"string\") {","                step = byId(step);","            }","            return (step && step.id && stepsData[\"impress-\" + step.id]) ? step : null;","        };","        ","        // used to reset timeout for `impress:stepenter` event","        var stepEnterTimeout = null;","        ","        // `goto` API function that moves to step given with `el` parameter (by index, id or element),","        // with a transition `duration` optionally given as second parameter.","        var goto = function ( el, duration ) {","            ","            if ( !initialized || !(el = getStep(el)) ) {","                // presentation not initialized or given element is not a step","                return false;","            }","            ","            // Sometimes it's possible to trigger focus on first link with some keyboard action.","            // Browser in such a case tries to scroll the page to make this element visible","            // (even that body overflow is set to hidden) and it breaks our careful positioning.","            //","            // So, as a lousy (and lazy) workaround we will make the page scroll back to the top","            // whenever slide is selected","            //","            // If you are reading this and know any better way to handle it, I'll be glad to hear about it!","            window.scrollTo(0, 0);","            ","            var step = stepsData[\"impress-\" + el.id];","            ","            if ( activeStep ) {","                activeStep.classList.remove(\"active\");","                body.classList.remove(\"impress-on-\" + activeStep.id);","            }","            el.classList.add(\"active\");","            ","            body.classList.add(\"impress-on-\" + el.id);","            ","            // compute target state of the canvas based on given step","            var target = {","                rotate: {","                    x: -step.rotate.x,","                    y: -step.rotate.y,","                    z: -step.rotate.z","                },","                translate: {","                    x: -step.translate.x,","                    y: -step.translate.y,","                    z: -step.translate.z","                },","                scale: 1 / step.scale","            };","            ","            // Check if the transition is zooming in or not.","            //","            // This information is used to alter the transition style:","            // when we are zooming in - we start with move and rotate transition","            // and the scaling is delayed, but when we are zooming out we start","            // with scaling down and move and rotation are delayed.","            var zoomin = target.scale >= currentState.scale;","            ","            duration = toNumber(duration, config.transitionDuration);","            var delay = (duration / 2);","            ","            // if the same step is re-selected, force computing window scaling,","            // because it is likely to be caused by window resize","            if (el === activeStep) {","                windowScale = computeWindowScale(config);","            }","            ","            var targetScale = target.scale * windowScale;","            ","            // trigger leave of currently active element (if it's not the same step again)","            if (activeStep && activeStep !== el) {","                onStepLeave(activeStep);","            }","            ","            // Now we alter transforms of `root` and `canvas` to trigger transitions.","            //","            // And here is why there are two elements: `root` and `canvas` - they are","            // being animated separately:","            // `root` is used for scaling and `canvas` for translate and rotations.","            // Transitions on them are triggered with different delays (to make","            // visually nice and 'natural' looking transitions), so we need to know","            // that both of them are finished.","            css(root, {","                // to keep the perspective look similar for different scales","                // we need to 'scale' the perspective, too","                transform: perspective( config.perspective / targetScale ) + scale( targetScale ),","                transitionDuration: duration + \"ms\",","                transitionDelay: (zoomin ? delay : 0) + \"ms\"","            });","            ","            css(canvas, {","                transform: rotate(target.rotate, true) + translate(target.translate),","                transitionDuration: duration + \"ms\",","                transitionDelay: (zoomin ? 0 : delay) + \"ms\"","            });","            ","            // Here is a tricky part...","            //","            // If there is no change in scale or no change in rotation and translation, it means there was actually","            // no delay - because there was no transition on `root` or `canvas` elements.","            // We want to trigger `impress:stepenter` event in the correct moment, so here we compare the current","            // and target values to check if delay should be taken into account.","            //","            // I know that this `if` statement looks scary, but it's pretty simple when you know what is going on","            // - it's simply comparing all the values.","            if ( currentState.scale === target.scale ||","                (currentState.rotate.x === target.rotate.x && currentState.rotate.y === target.rotate.y &&","                 currentState.rotate.z === target.rotate.z && currentState.translate.x === target.translate.x &&","                 currentState.translate.y === target.translate.y && currentState.translate.z === target.translate.z) ) {","                delay = 0;","            }","            ","            // store current state","            currentState = target;","            activeStep = el;","            ","            // And here is where we trigger `impress:stepenter` event.","            // We simply set up a timeout to fire it taking transition duration (and possible delay) into account.","            //","            // I really wanted to make it in more elegant way. The `transitionend` event seemed to be the best way","            // to do it, but the fact that I'm using transitions on two separate elements and that the `transitionend`","            // event is only triggered when there was a transition (change in the values) caused some bugs and ","            // made the code really complicated, cause I had to handle all the conditions separately. And it still","            // needed a `setTimeout` fallback for the situations when there is no transition at all.","            // So I decided that I'd rather make the code simpler than use shiny new `transitionend`.","            //","            // If you want learn something interesting and see how it was done with `transitionend` go back to","            // version 0.5.2 of impress.js: http://github.com/bartaz/impress.js/blob/0.5.2/js/impress.js","            window.clearTimeout(stepEnterTimeout);","            stepEnterTimeout = window.setTimeout(function() {","                onStepEnter(activeStep);","            }, duration + delay);","            ","            return el;","        };","        ","        // `prev` API function goes to previous step (in document order)","        var prev = function () {","            var prev = steps.indexOf( activeStep ) - 1;","            prev = prev >= 0 ? steps[ prev ] : steps[ steps.length-1 ];","            ","            return goto(prev);","        };","        ","        // `next` API function goes to next step (in document order)","        var next = function () {","            var next = steps.indexOf( activeStep ) + 1;","            next = next < steps.length ? steps[ next ] : steps[ 0 ];","            ","            return goto(next);","        };","        ","        // Adding some useful classes to step elements.","        //","        // All the steps that have not been shown yet are given `future` class.","        // When the step is entered the `future` class is removed and the `present`","        // class is given. When the step is left `present` class is replaced with","        // `past` class.","        //","        // So every step element is always in one of three possible states:","        // `future`, `present` and `past`.","        //","        // There classes can be used in CSS to style different types of steps.","        // For example the `present` class can be used to trigger some custom","        // animations when step is shown.","        root.addEventListener(\"impress:init\", function(){","            // STEP CLASSES","            steps.forEach(function (step) {","                step.classList.add(\"future\");","            });","            ","            root.addEventListener(\"impress:stepenter\", function (event) {","                event.target.classList.remove(\"past\");","                event.target.classList.remove(\"future\");","                event.target.classList.add(\"present\");","            }, false);","            ","            root.addEventListener(\"impress:stepleave\", function (event) {","                event.target.classList.remove(\"present\");","                event.target.classList.add(\"past\");","            }, false);","            ","        }, false);","        ","        // Adding hash change support.","        root.addEventListener(\"impress:init\", function(){","            ","            // last hash detected","            var lastHash = \"\";","            ","            // `#/step-id` is used instead of `#step-id` to prevent default browser","            // scrolling to element in hash.","            //","            // And it has to be set after animation finishes, because in Chrome it","            // makes transtion laggy.","            // BUG: http://code.google.com/p/chromium/issues/detail?id=62820","            root.addEventListener(\"impress:stepenter\", function (event) {","                window.location.hash = lastHash = \"#/\" + event.target.id;","            }, false);","            ","            window.addEventListener(\"hashchange\", function () {","                // When the step is entered hash in the location is updated","                // (just few lines above from here), so the hash change is ","                // triggered and we would call `goto` again on the same element.","                //","                // To avoid this we store last entered hash and compare.","                if (window.location.hash !== lastHash) {","                    goto( getElementFromHash() );","                }","            }, false);","            ","            // START ","            // by selecting step defined in url or first step of the presentation","            goto(getElementFromHash() || steps[0], 0);","        }, false);","        ","        body.classList.add(\"impress-disabled\");","        ","        // store and return API for given impress.js root element","        return (roots[ \"impress-root-\" + rootId ] = {","            init: init,","            goto: goto,","            next: next,","            prev: prev","        });","","    };","    ","    // flag that can be used in JS to check if browser have passed the support test","    impress.supported = impressSupported;","    ","})(document, window);","","// NAVIGATION EVENTS","","// As you can see this part is separate from the impress.js core code.","// It's because these navigation actions only need what impress.js provides with","// its simple API.","//","// In future I think about moving it to make them optional, move to separate files","// and treat more like a 'plugins'.","(function ( document, window ) {","    'use strict';","    ","    // throttling function calls, by Remy Sharp","    // http://remysharp.com/2010/07/21/throttling-function-calls/","    var throttle = function (fn, delay) {","        var timer = null;","        return function () {","            var context = this, args = arguments;","            clearTimeout(timer);","            timer = setTimeout(function () {","                fn.apply(context, args);","            }, delay);","        };","    };","    ","    // wait for impress.js to be initialized","    document.addEventListener(\"impress:init\", function (event) {","        // Getting API from event data.","        // So you don't event need to know what is the id of the root element","        // or anything. `impress:init` event data gives you everything you ","        // need to control the presentation that was just initialized.","        var api = event.detail.api;","        ","        // KEYBOARD NAVIGATION HANDLERS","        ","        // Prevent default keydown action when one of supported key is pressed.","        document.addEventListener(\"keydown\", function ( event ) {","            if ( event.keyCode === 9 || ( event.keyCode >= 32 && event.keyCode <= 34 ) || (event.keyCode >= 37 && event.keyCode <= 40) ) {","                event.preventDefault();","            }","        }, false);","        ","        // Trigger impress action (next or prev) on keyup.","        ","        // Supported keys are:","        // [space] - quite common in presentation software to move forward","        // [up] [right] / [down] [left] - again common and natural addition,","        // [pgdown] / [pgup] - often triggered by remote controllers,","        // [tab] - this one is quite controversial, but the reason it ended up on","        //   this list is quite an interesting story... Remember that strange part","        //   in the impress.js code where window is scrolled to 0,0 on every presentation","        //   step, because sometimes browser scrolls viewport because of the focused element?","        //   Well, the [tab] key by default navigates around focusable elements, so clicking","        //   it very often caused scrolling to focused element and breaking impress.js","        //   positioning. I didn't want to just prevent this default action, so I used [tab]","        //   as another way to moving to next step... And yes, I know that for the sake of","        //   consistency I should add [shift+tab] as opposite action...","        document.addEventListener(\"keyup\", function ( event ) {","            if ( event.keyCode === 9 || ( event.keyCode >= 32 && event.keyCode <= 34 ) || (event.keyCode >= 37 && event.keyCode <= 40) ) {","                switch( event.keyCode ) {","                    case 33: // pg up","                    case 37: // left","                    case 38: // up","                             api.prev();","                             break;","                    case 9:  // tab","                    case 32: // space","                    case 34: // pg down","                    case 39: // right","                    case 40: // down","                             api.next();","                             break;","                }","                ","                event.preventDefault();","            }","        }, false);","        ","        // delegated handler for clicking on the links to presentation steps","        document.addEventListener(\"click\", function ( event ) {","            // event delegation with \"bubbling\"","            // check if event target (or any of its parents is a link)","            var target = event.target;","            while ( (target.tagName !== \"A\") &&","                    (target !== document.documentElement) ) {","                target = target.parentNode;","            }","            ","            if ( target.tagName === \"A\" ) {","                var href = target.getAttribute(\"href\");","                ","                // if it's a link to presentation step, target this step","                if ( href && href[0] === '#' ) {","                    target = document.getElementById( href.slice(1) );","                }","            }","            ","            if ( api.goto(target) ) {","                event.stopImmediatePropagation();","                event.preventDefault();","            }","        }, false);","        ","        // delegated handler for clicking on step elements","        document.addEventListener(\"click\", function ( event ) {","            var target = event.target;","            // find closest step element that is not active","            while ( !(target.classList.contains(\"step\") && !target.classList.contains(\"active\")) &&","                    (target !== document.documentElement) ) {","                target = target.parentNode;","            }","            ","            if ( api.goto(target) ) {","                event.preventDefault();","            }","        }, false);","        ","        // touch handler to detect taps on the left and right side of the screen","        // based on awesome work of @hakimel: https://github.com/hakimel/reveal.js","        document.addEventListener(\"touchstart\", function ( event ) {","            if (event.touches.length === 1) {","                var x = event.touches[0].clientX,","                    width = window.innerWidth * 0.3,","                    result = null;","                    ","                if ( x < width ) {","                    result = api.prev();","                } else if ( x > window.innerWidth - width ) {","                    result = api.next();","                }","                ","                if (result) {","                    event.preventDefault();","                }","            }","        }, false);","        ","        // rescale presentation when window is resized","        window.addEventListener(\"resize\", throttle(function () {","            // force going to active step again, to trigger rescaling","            api.goto( document.querySelector(\".step.active\"), 500 );","        }, 250), false);","        ","    }, false);","        ","})(document, window);","","// THAT'S ALL FOLKS!","//","// Thanks for reading it all.","// Or thanks for scrolling down and reading the last part.","//","// I've learnt a lot when building impress.js and I hope this code and comments","// will help somebody learn at least some part of it."]},{"start":{"row":0,"column":0},"end":{"row":4276,"column":0},"action":"insert","lines":["/*!"," * reveal.js"," * http://lab.hakim.se/reveal-js"," * MIT licensed"," *"," * Copyright (C) 2015 Hakim El Hattab, http://hakim.se"," */","(function( root, factory ) {","\tif( typeof define === 'function' && define.amd ) {","\t\t// AMD. Register as an anonymous module.","\t\tdefine( function() {","\t\t\troot.Reveal = factory();","\t\t\treturn root.Reveal;","\t\t} );","\t} else if( typeof exports === 'object' ) {","\t\t// Node. Does not work with strict CommonJS.","\t\tmodule.exports = factory();","\t} else {","\t\t// Browser globals.","\t\troot.Reveal = factory();","\t}","}( this, function() {","","\t'use strict';","","\tvar Reveal;","","\tvar SLIDES_SELECTOR = '.slides section',","\t\tHORIZONTAL_SLIDES_SELECTOR = '.slides>section',","\t\tVERTICAL_SLIDES_SELECTOR = '.slides>section.present>section',","\t\tHOME_SLIDE_SELECTOR = '.slides>section:first-of-type',","","\t\t// Configurations defaults, can be overridden at initialization time","\t\tconfig = {","","\t\t\t// The \"normal\" size of the presentation, aspect ratio will be preserved","\t\t\t// when the presentation is scaled to fit different resolutions","\t\t\twidth: 960,","\t\t\theight: 700,","","\t\t\t// Factor of the display size that should remain empty around the content","\t\t\tmargin: 0.1,","","\t\t\t// Bounds for smallest/largest possible scale to apply to content","\t\t\tminScale: 0.2,","\t\t\tmaxScale: 1.5,","","\t\t\t// Display controls in the bottom right corner","\t\t\tcontrols: true,","","\t\t\t// Display a presentation progress bar","\t\t\tprogress: true,","","\t\t\t// Display the page number of the current slide","\t\t\tslideNumber: false,","","\t\t\t// Push each slide change to the browser history","\t\t\thistory: false,","","\t\t\t// Enable keyboard shortcuts for navigation","\t\t\tkeyboard: true,","","\t\t\t// Optional function that blocks keyboard events when retuning false","\t\t\tkeyboardCondition: null,","","\t\t\t// Enable the slide overview mode","\t\t\toverview: true,","","\t\t\t// Vertical centering of slides","\t\t\tcenter: true,","","\t\t\t// Enables touch navigation on devices with touch input","\t\t\ttouch: true,","","\t\t\t// Loop the presentation","\t\t\tloop: false,","","\t\t\t// Change the presentation direction to be RTL","\t\t\trtl: false,","","\t\t\t// Turns fragments on and off globally","\t\t\tfragments: true,","","\t\t\t// Flags if the presentation is running in an embedded mode,","\t\t\t// i.e. contained within a limited portion of the screen","\t\t\tembedded: false,","","\t\t\t// Flags if we should show a help overlay when the questionmark","\t\t\t// key is pressed","\t\t\thelp: true,","","\t\t\t// Flags if it should be possible to pause the presentation (blackout)","\t\t\tpause: true,","","\t\t\t// Number of milliseconds between automatically proceeding to the","\t\t\t// next slide, disabled when set to 0, this value can be overwritten","\t\t\t// by using a data-autoslide attribute on your slides","\t\t\tautoSlide: 0,","","\t\t\t// Stop auto-sliding after user input","\t\t\tautoSlideStoppable: true,","","\t\t\t// Enable slide navigation via mouse wheel","\t\t\tmouseWheel: false,","","\t\t\t// Apply a 3D roll to links on hover","\t\t\trollingLinks: false,","","\t\t\t// Hides the address bar on mobile devices","\t\t\thideAddressBar: true,","","\t\t\t// Opens links in an iframe preview overlay","\t\t\tpreviewLinks: false,","","\t\t\t// Exposes the reveal.js API through window.postMessage","\t\t\tpostMessage: true,","","\t\t\t// Dispatches all reveal.js events to the parent window through postMessage","\t\t\tpostMessageEvents: false,","","\t\t\t// Focuses body when page changes visiblity to ensure keyboard shortcuts work","\t\t\tfocusBodyOnPageVisibilityChange: true,","","\t\t\t// Transition style","\t\t\ttransition: 'slide', // none/fade/slide/convex/concave/zoom","","\t\t\t// Transition speed","\t\t\ttransitionSpeed: 'default', // default/fast/slow","","\t\t\t// Transition style for full page slide backgrounds","\t\t\tbackgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom","","\t\t\t// Parallax background image","\t\t\tparallaxBackgroundImage: '', // CSS syntax, e.g. \"a.jpg\"","","\t\t\t// Parallax background size","\t\t\tparallaxBackgroundSize: '', // CSS syntax, e.g. \"3000px 2000px\"","","\t\t\t// Number of slides away from the current that are visible","\t\t\tviewDistance: 3,","","\t\t\t// Script dependencies to load","\t\t\tdependencies: []","","\t\t},","","\t\t// Flags if reveal.js is loaded (has dispatched the 'ready' event)","\t\tloaded = false,","","\t\t// The horizontal and vertical index of the currently active slide","\t\tindexh,","\t\tindexv,","","\t\t// The previous and current slide HTML elements","\t\tpreviousSlide,","\t\tcurrentSlide,","","\t\tpreviousBackground,","","\t\t// Slides may hold a data-state attribute which we pick up and apply","\t\t// as a class to the body. This list contains the combined state of","\t\t// all current slides.","\t\tstate = [],","","\t\t// The current scale of the presentation (see width/height config)","\t\tscale = 1,","","\t\t// Cached references to DOM elements","\t\tdom = {},","","\t\t// Features supported by the browser, see #checkCapabilities()","\t\tfeatures = {},","","\t\t// Client is a mobile device, see #checkCapabilities()","\t\tisMobileDevice,","","\t\t// Throttles mouse wheel navigation","\t\tlastMouseWheelStep = 0,","","\t\t// Delays updates to the URL due to a Chrome thumbnailer bug","\t\twriteURLTimeout = 0,","","\t\t// Flags if the interaction event listeners are bound","\t\teventsAreBound = false,","","\t\t// The current auto-slide duration","\t\tautoSlide = 0,","","\t\t// Auto slide properties","\t\tautoSlidePlayer,","\t\tautoSlideTimeout = 0,","\t\tautoSlideStartTime = -1,","\t\tautoSlidePaused = false,","","\t\t// Holds information about the currently ongoing touch input","\t\ttouch = {","\t\t\tstartX: 0,","\t\t\tstartY: 0,","\t\t\tstartSpan: 0,","\t\t\tstartCount: 0,","\t\t\tcaptured: false,","\t\t\tthreshold: 40","\t\t},","","\t\t// Holds information about the keyboard shortcuts","\t\tkeyboardShortcuts = {","\t\t\t'N  ,  SPACE':\t\t\t'Next slide',","\t\t\t'P':\t\t\t\t\t'Previous slide',","\t\t\t'&#8592;  ,  H':\t\t'Navigate left',","\t\t\t'&#8594;  ,  L':\t\t'Navigate right',","\t\t\t'&#8593;  ,  K':\t\t'Navigate up',","\t\t\t'&#8595;  ,  J':\t\t'Navigate down',","\t\t\t'Home':\t\t\t\t\t'First slide',","\t\t\t'End':\t\t\t\t\t'Last slide',","\t\t\t'B  ,  .':\t\t\t\t'Pause',","\t\t\t'F':\t\t\t\t\t'Fullscreen',","\t\t\t'ESC, O':\t\t\t\t'Slide overview'","\t\t};","","\t/**","\t * Starts up the presentation if the client is capable.","\t */","\tfunction initialize( options ) {","","\t\tcheckCapabilities();","","\t\tif( !features.transforms2d && !features.transforms3d ) {","\t\t\tdocument.body.setAttribute( 'class', 'no-transforms' );","","\t\t\t// Since JS won't be running any further, we need to load all","\t\t\t// images that were intended to lazy load now","\t\t\tvar images = document.getElementsByTagName( 'img' );","\t\t\tfor( var i = 0, len = images.length; i < len; i++ ) {","\t\t\t\tvar image = images[i];","\t\t\t\tif( image.getAttribute( 'data-src' ) ) {","\t\t\t\t\timage.setAttribute( 'src', image.getAttribute( 'data-src' ) );","\t\t\t\t\timage.removeAttribute( 'data-src' );","\t\t\t\t}","\t\t\t}","","\t\t\t// If the browser doesn't support core features we won't be","\t\t\t// using JavaScript to control the presentation","\t\t\treturn;","\t\t}","","\t\t// Cache references to key DOM elements","\t\tdom.wrapper = document.querySelector( '.reveal' );","\t\tdom.slides = document.querySelector( '.reveal .slides' );","","\t\t// Force a layout when the whole page, incl fonts, has loaded","\t\twindow.addEventListener( 'load', layout, false );","","\t\tvar query = Reveal.getQueryHash();","","\t\t// Do not accept new dependencies via query config to avoid","\t\t// the potential of malicious script injection","\t\tif( typeof query['dependencies'] !== 'undefined' ) delete query['dependencies'];","","\t\t// Copy options over to our config object","\t\textend( config, options );","\t\textend( config, query );","","\t\t// Hide the address bar in mobile browsers","\t\thideAddressBar();","","\t\t// Loads the dependencies and continues to #start() once done","\t\tload();","","\t}","","\t/**","\t * Inspect the client to see what it's capable of, this","\t * should only happens once per runtime.","\t */","\tfunction checkCapabilities() {","","\t\tfeatures.transforms3d = 'WebkitPerspective' in document.body.style ||","\t\t\t\t\t\t\t\t'MozPerspective' in document.body.style ||","\t\t\t\t\t\t\t\t'msPerspective' in document.body.style ||","\t\t\t\t\t\t\t\t'OPerspective' in document.body.style ||","\t\t\t\t\t\t\t\t'perspective' in document.body.style;","","\t\tfeatures.transforms2d = 'WebkitTransform' in document.body.style ||","\t\t\t\t\t\t\t\t'MozTransform' in document.body.style ||","\t\t\t\t\t\t\t\t'msTransform' in document.body.style ||","\t\t\t\t\t\t\t\t'OTransform' in document.body.style ||","\t\t\t\t\t\t\t\t'transform' in document.body.style;","","\t\tfeatures.requestAnimationFrameMethod = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;","\t\tfeatures.requestAnimationFrame = typeof features.requestAnimationFrameMethod === 'function';","","\t\tfeatures.canvas = !!document.createElement( 'canvas' ).getContext;","","\t\tfeatures.touch = !!( 'ontouchstart' in window );","","\t\tisMobileDevice = navigator.userAgent.match( /(iphone|ipod|ipad|android)/gi );","","\t}","","    /**","     * Loads the dependencies of reveal.js. Dependencies are","     * defined via the configuration option 'dependencies'","     * and will be loaded prior to starting/binding reveal.js.","     * Some dependencies may have an 'async' flag, if so they","     * will load after reveal.js has been started up.","     */","\tfunction load() {","","\t\tvar scripts = [],","\t\t\tscriptsAsync = [],","\t\t\tscriptsToPreload = 0;","","\t\t// Called once synchronous scripts finish loading","\t\tfunction proceed() {","\t\t\tif( scriptsAsync.length ) {","\t\t\t\t// Load asynchronous scripts","\t\t\t\thead.js.apply( null, scriptsAsync );","\t\t\t}","","\t\t\tstart();","\t\t}","","\t\tfunction loadScript( s ) {","\t\t\thead.ready( s.src.match( /([\\w\\d_\\-]*)\\.?js$|[^\\\\\\/]*$/i )[0], function() {","\t\t\t\t// Extension may contain callback functions","\t\t\t\tif( typeof s.callback === 'function' ) {","\t\t\t\t\ts.callback.apply( this );","\t\t\t\t}","","\t\t\t\tif( --scriptsToPreload === 0 ) {","\t\t\t\t\tproceed();","\t\t\t\t}","\t\t\t});","\t\t}","","\t\tfor( var i = 0, len = config.dependencies.length; i < len; i++ ) {","\t\t\tvar s = config.dependencies[i];","","\t\t\t// Load if there's no condition or the condition is truthy","\t\t\tif( !s.condition || s.condition() ) {","\t\t\t\tif( s.async ) {","\t\t\t\t\tscriptsAsync.push( s.src );","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\tscripts.push( s.src );","\t\t\t\t}","","\t\t\t\tloadScript( s );","\t\t\t}","\t\t}","","\t\tif( scripts.length ) {","\t\t\tscriptsToPreload = scripts.length;","","\t\t\t// Load synchronous scripts","\t\t\thead.js.apply( null, scripts );","\t\t}","\t\telse {","\t\t\tproceed();","\t\t}","","\t}","","\t/**","\t * Starts up reveal.js by binding input events and navigating","\t * to the current URL deeplink if there is one.","\t */","\tfunction start() {","","\t\t// Make sure we've got all the DOM elements we need","\t\tsetupDOM();","","\t\t// Listen to messages posted to this window","\t\tsetupPostMessage();","","\t\t// Resets all vertical slides so that only the first is visible","\t\tresetVerticalSlides();","","\t\t// Updates the presentation to match the current configuration values","\t\tconfigure();","","\t\t// Read the initial hash","\t\treadURL();","","\t\t// Update all backgrounds","\t\tupdateBackground( true );","","\t\t// Notify listeners that the presentation is ready but use a 1ms","\t\t// timeout to ensure it's not fired synchronously after #initialize()","\t\tsetTimeout( function() {","\t\t\t// Enable transitions now that we're loaded","\t\t\tdom.slides.classList.remove( 'no-transition' );","","\t\t\tloaded = true;","","\t\t\tdispatchEvent( 'ready', {","\t\t\t\t'indexh': indexh,","\t\t\t\t'indexv': indexv,","\t\t\t\t'currentSlide': currentSlide","\t\t\t} );","\t\t}, 1 );","","\t\t// Special setup and config is required when printing to PDF","\t\tif( isPrintingPDF() ) {","\t\t\tremoveEventListeners();","","\t\t\t// The document needs to have loaded for the PDF layout","\t\t\t// measurements to be accurate","\t\t\tif( document.readyState === 'complete' ) {","\t\t\t\tsetupPDF();","\t\t\t}","\t\t\telse {","\t\t\t\twindow.addEventListener( 'load', setupPDF );","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Finds and stores references to DOM elements which are","\t * required by the presentation. If a required element is","\t * not found, it is created.","\t */","\tfunction setupDOM() {","","\t\t// Prevent transitions while we're loading","\t\tdom.slides.classList.add( 'no-transition' );","","\t\t// Background element","\t\tdom.background = createSingletonNode( dom.wrapper, 'div', 'backgrounds', null );","","\t\t// Progress bar","\t\tdom.progress = createSingletonNode( dom.wrapper, 'div', 'progress', '<span></span>' );","\t\tdom.progressbar = dom.progress.querySelector( 'span' );","","\t\t// Arrow controls","\t\tcreateSingletonNode( dom.wrapper, 'aside', 'controls',","\t\t\t'<div class=\"navigate-left\"></div>' +","\t\t\t'<div class=\"navigate-right\"></div>' +","\t\t\t'<div class=\"navigate-up\"></div>' +","\t\t\t'<div class=\"navigate-down\"></div>' );","","\t\t// Slide number","\t\tdom.slideNumber = createSingletonNode( dom.wrapper, 'div', 'slide-number', '' );","","\t\t// Overlay graphic which is displayed during the paused mode","\t\tcreateSingletonNode( dom.wrapper, 'div', 'pause-overlay', null );","","\t\t// Cache references to elements","\t\tdom.controls = document.querySelector( '.reveal .controls' );","\t\tdom.theme = document.querySelector( '#theme' );","","\t\tdom.wrapper.setAttribute( 'role', 'application' );","","\t\t// There can be multiple instances of controls throughout the page","\t\tdom.controlsLeft = toArray( document.querySelectorAll( '.navigate-left' ) );","\t\tdom.controlsRight = toArray( document.querySelectorAll( '.navigate-right' ) );","\t\tdom.controlsUp = toArray( document.querySelectorAll( '.navigate-up' ) );","\t\tdom.controlsDown = toArray( document.querySelectorAll( '.navigate-down' ) );","\t\tdom.controlsPrev = toArray( document.querySelectorAll( '.navigate-prev' ) );","\t\tdom.controlsNext = toArray( document.querySelectorAll( '.navigate-next' ) );","","\t\tdom.statusDiv = createStatusDiv();","\t}","","\t/**","\t * Creates a hidden div with role aria-live to announce the","\t * current slide content. Hide the div off-screen to make it","\t * available only to Assistive Technologies.","\t */","\tfunction createStatusDiv() {","","\t\tvar statusDiv = document.getElementById( 'aria-status-div' );","\t\tif( !statusDiv ) {","\t\t\tstatusDiv = document.createElement( 'div' );","\t\t\tstatusDiv.style.position = 'absolute';","\t\t\tstatusDiv.style.height = '1px';","\t\t\tstatusDiv.style.width = '1px';","\t\t\tstatusDiv.style.overflow ='hidden';","\t\t\tstatusDiv.style.clip = 'rect( 1px, 1px, 1px, 1px )';","\t\t\tstatusDiv.setAttribute( 'id', 'aria-status-div' );","\t\t\tstatusDiv.setAttribute( 'aria-live', 'polite' );","\t\t\tstatusDiv.setAttribute( 'aria-atomic','true' );","\t\t\tdom.wrapper.appendChild( statusDiv );","\t\t}","\t\treturn statusDiv;","","\t}","","\t/**","\t * Configures the presentation for printing to a static","\t * PDF.","\t */","\tfunction setupPDF() {","","\t\tvar slideSize = getComputedSlideSize( window.innerWidth, window.innerHeight );","","\t\t// Dimensions of the PDF pages","\t\tvar pageWidth = Math.floor( slideSize.width * ( 1 + config.margin ) ),","\t\t\tpageHeight = Math.floor( slideSize.height * ( 1 + config.margin  ) );","","\t\t// Dimensions of slides within the pages","\t\tvar slideWidth = slideSize.width,","\t\t\tslideHeight = slideSize.height;","","\t\t// Let the browser know what page size we want to print","\t\tinjectStyleSheet( '@page{size:'+ pageWidth +'px '+ pageHeight +'px; margin: 0;}' );","","\t\t// Limit the size of certain elements to the dimensions of the slide","\t\tinjectStyleSheet( '.reveal section>img, .reveal section>video, .reveal section>iframe{max-width: '+ slideWidth +'px; max-height:'+ slideHeight +'px}' );","","\t\tdocument.body.classList.add( 'print-pdf' );","\t\tdocument.body.style.width = pageWidth + 'px';","\t\tdocument.body.style.height = pageHeight + 'px';","","\t\t// Slide and slide background layout","\t\ttoArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {","","\t\t\t// Vertical stacks are not centred since their section","\t\t\t// children will be","\t\t\tif( slide.classList.contains( 'stack' ) === false ) {","\t\t\t\t// Center the slide inside of the page, giving the slide some margin","\t\t\t\tvar left = ( pageWidth - slideWidth ) / 2,","\t\t\t\t\ttop = ( pageHeight - slideHeight ) / 2;","","\t\t\t\tvar contentHeight = getAbsoluteHeight( slide );","\t\t\t\tvar numberOfPages = Math.max( Math.ceil( contentHeight / pageHeight ), 1 );","","\t\t\t\t// Center slides vertically","\t\t\t\tif( numberOfPages === 1 && config.center || slide.classList.contains( 'center' ) ) {","\t\t\t\t\ttop = Math.max( ( pageHeight - contentHeight ) / 2, 0 );","\t\t\t\t}","","\t\t\t\t// Position the slide inside of the page","\t\t\t\tslide.style.left = left + 'px';","\t\t\t\tslide.style.top = top + 'px';","\t\t\t\tslide.style.width = slideWidth + 'px';","","\t\t\t\t// TODO Backgrounds need to be multiplied when the slide","\t\t\t\t// stretches over multiple pages","\t\t\t\tvar background = slide.querySelector( '.slide-background' );","\t\t\t\tif( background ) {","\t\t\t\t\tbackground.style.width = pageWidth + 'px';","\t\t\t\t\tbackground.style.height = ( pageHeight * numberOfPages ) + 'px';","\t\t\t\t\tbackground.style.top = -top + 'px';","\t\t\t\t\tbackground.style.left = -left + 'px';","\t\t\t\t}","\t\t\t}","","\t\t} );","","\t\t// Show all fragments","\t\ttoArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' .fragment' ) ).forEach( function( fragment ) {","\t\t\tfragment.classList.add( 'visible' );","\t\t} );","","\t}","","\t/**","\t * Creates an HTML element and returns a reference to it.","\t * If the element already exists the existing instance will","\t * be returned.","\t */","\tfunction createSingletonNode( container, tagname, classname, innerHTML ) {","","\t\t// Find all nodes matching the description","\t\tvar nodes = container.querySelectorAll( '.' + classname );","","\t\t// Check all matches to find one which is a direct child of","\t\t// the specified container","\t\tfor( var i = 0; i < nodes.length; i++ ) {","\t\t\tvar testNode = nodes[i];","\t\t\tif( testNode.parentNode === container ) {","\t\t\t\treturn testNode;","\t\t\t}","\t\t}","","\t\t// If no node was found, create it now","\t\tvar node = document.createElement( tagname );","\t\tnode.classList.add( classname );","\t\tif( typeof innerHTML === 'string' ) {","\t\t\tnode.innerHTML = innerHTML;","\t\t}","\t\tcontainer.appendChild( node );","","\t\treturn node;","","\t}","","\t/**","\t * Creates the slide background elements and appends them","\t * to the background container. One element is created per","\t * slide no matter if the given slide has visible background.","\t */","\tfunction createBackgrounds() {","","\t\tvar printMode = isPrintingPDF();","","\t\t// Clear prior backgrounds","\t\tdom.background.innerHTML = '';","\t\tdom.background.classList.add( 'no-transition' );","","\t\t// Iterate over all horizontal slides","\t\ttoArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).forEach( function( slideh ) {","","\t\t\tvar backgroundStack;","","\t\t\tif( printMode ) {","\t\t\t\tbackgroundStack = createBackground( slideh, slideh );","\t\t\t}","\t\t\telse {","\t\t\t\tbackgroundStack = createBackground( slideh, dom.background );","\t\t\t}","","\t\t\t// Iterate over all vertical slides","\t\t\ttoArray( slideh.querySelectorAll( 'section' ) ).forEach( function( slidev ) {","","\t\t\t\tif( printMode ) {","\t\t\t\t\tcreateBackground( slidev, slidev );","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\tcreateBackground( slidev, backgroundStack );","\t\t\t\t}","","\t\t\t\tbackgroundStack.classList.add( 'stack' );","","\t\t\t} );","","\t\t} );","","\t\t// Add parallax background if specified","\t\tif( config.parallaxBackgroundImage ) {","","\t\t\tdom.background.style.backgroundImage = 'url(\"' + config.parallaxBackgroundImage + '\")';","\t\t\tdom.background.style.backgroundSize = config.parallaxBackgroundSize;","","\t\t\t// Make sure the below properties are set on the element - these properties are","\t\t\t// needed for proper transitions to be set on the element via CSS. To remove","\t\t\t// annoying background slide-in effect when the presentation starts, apply","\t\t\t// these properties after short time delay","\t\t\tsetTimeout( function() {","\t\t\t\tdom.wrapper.classList.add( 'has-parallax-background' );","\t\t\t}, 1 );","","\t\t}","\t\telse {","","\t\t\tdom.background.style.backgroundImage = '';","\t\t\tdom.wrapper.classList.remove( 'has-parallax-background' );","","\t\t}","","\t}","","\t/**","\t * Creates a background for the given slide.","\t *","\t * @param {HTMLElement} slide","\t * @param {HTMLElement} container The element that the background","\t * should be appended to","\t */","\tfunction createBackground( slide, container ) {","","\t\tvar data = {","\t\t\tbackground: slide.getAttribute( 'data-background' ),","\t\t\tbackgroundSize: slide.getAttribute( 'data-background-size' ),","\t\t\tbackgroundImage: slide.getAttribute( 'data-background-image' ),","\t\t\tbackgroundVideo: slide.getAttribute( 'data-background-video' ),","\t\t\tbackgroundIframe: slide.getAttribute( 'data-background-iframe' ),","\t\t\tbackgroundColor: slide.getAttribute( 'data-background-color' ),","\t\t\tbackgroundRepeat: slide.getAttribute( 'data-background-repeat' ),","\t\t\tbackgroundPosition: slide.getAttribute( 'data-background-position' ),","\t\t\tbackgroundTransition: slide.getAttribute( 'data-background-transition' )","\t\t};","","\t\tvar element = document.createElement( 'div' );","","\t\t// Carry over custom classes from the slide to the background","\t\telement.className = 'slide-background ' + slide.className.replace( /present|past|future/, '' );","","\t\tif( data.background ) {","\t\t\t// Auto-wrap image urls in url(...)","\t\t\tif( /^(http|file|\\/\\/)/gi.test( data.background ) || /\\.(svg|png|jpg|jpeg|gif|bmp)$/gi.test( data.background ) ) {","\t\t\t\tslide.setAttribute( 'data-background-image', data.background );","\t\t\t}","\t\t\telse {","\t\t\t\telement.style.background = data.background;","\t\t\t}","\t\t}","","\t\t// Create a hash for this combination of background settings.","\t\t// This is used to determine when two slide backgrounds are","\t\t// the same.","\t\tif( data.background || data.backgroundColor || data.backgroundImage || data.backgroundVideo || data.backgroundIframe ) {","\t\t\telement.setAttribute( 'data-background-hash', data.background +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundSize +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundImage +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundVideo +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundIframe +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundColor +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundRepeat +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundPosition +","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundTransition );","\t\t}","","\t\t// Additional and optional background properties","\t\tif( data.backgroundSize ) element.style.backgroundSize = data.backgroundSize;","\t\tif( data.backgroundColor ) element.style.backgroundColor = data.backgroundColor;","\t\tif( data.backgroundRepeat ) element.style.backgroundRepeat = data.backgroundRepeat;","\t\tif( data.backgroundPosition ) element.style.backgroundPosition = data.backgroundPosition;","\t\tif( data.backgroundTransition ) element.setAttribute( 'data-background-transition', data.backgroundTransition );","","\t\tcontainer.appendChild( element );","","\t\t// If backgrounds are being recreated, clear old classes","\t\tslide.classList.remove( 'has-dark-background' );","\t\tslide.classList.remove( 'has-light-background' );","","\t\t// If this slide has a background color, add a class that","\t\t// signals if it is light or dark. If the slide has no background","\t\t// color, no class will be set","\t\tvar computedBackgroundColor = window.getComputedStyle( element ).backgroundColor;","\t\tif( computedBackgroundColor ) {","\t\t\tvar rgb = colorToRgb( computedBackgroundColor );","","\t\t\t// Ignore fully transparent backgrounds. Some browsers return","\t\t\t// rgba(0,0,0,0) when reading the computed background color of","\t\t\t// an element with no background","\t\t\tif( rgb && rgb.a !== 0 ) {","\t\t\t\tif( colorBrightness( computedBackgroundColor ) < 128 ) {","\t\t\t\t\tslide.classList.add( 'has-dark-background' );","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\tslide.classList.add( 'has-light-background' );","\t\t\t\t}","\t\t\t}","\t\t}","","\t\treturn element;","","\t}","","\t/**","\t * Registers a listener to postMessage events, this makes it","\t * possible to call all reveal.js API methods from another","\t * window. For example:","\t *","\t * revealWindow.postMessage( JSON.stringify({","\t *   method: 'slide',","\t *   args: [ 2 ]","\t * }), '*' );","\t */","\tfunction setupPostMessage() {","","\t\tif( config.postMessage ) {","\t\t\twindow.addEventListener( 'message', function ( event ) {","\t\t\t\tvar data = event.data;","","\t\t\t\t// Make sure we're dealing with JSON","\t\t\t\tif( data.charAt( 0 ) === '{' && data.charAt( data.length - 1 ) === '}' ) {","\t\t\t\t\tdata = JSON.parse( data );","","\t\t\t\t\t// Check if the requested method can be found","\t\t\t\t\tif( data.method && typeof Reveal[data.method] === 'function' ) {","\t\t\t\t\t\tReveal[data.method].apply( Reveal, data.args );","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}, false );","\t\t}","","\t}","","\t/**","\t * Applies the configuration settings from the config","\t * object. May be called multiple times.","\t */","\tfunction configure( options ) {","","\t\tvar numberOfSlides = dom.wrapper.querySelectorAll( SLIDES_SELECTOR ).length;","","\t\tdom.wrapper.classList.remove( config.transition );","","\t\t// New config options may be passed when this method","\t\t// is invoked through the API after initialization","\t\tif( typeof options === 'object' ) extend( config, options );","","\t\t// Force linear transition based on browser capabilities","\t\tif( features.transforms3d === false ) config.transition = 'linear';","","\t\tdom.wrapper.classList.add( config.transition );","","\t\tdom.wrapper.setAttribute( 'data-transition-speed', config.transitionSpeed );","\t\tdom.wrapper.setAttribute( 'data-background-transition', config.backgroundTransition );","","\t\tdom.controls.style.display = config.controls ? 'block' : 'none';","\t\tdom.progress.style.display = config.progress ? 'block' : 'none';","","\t\tif( config.rtl ) {","\t\t\tdom.wrapper.classList.add( 'rtl' );","\t\t}","\t\telse {","\t\t\tdom.wrapper.classList.remove( 'rtl' );","\t\t}","","\t\tif( config.center ) {","\t\t\tdom.wrapper.classList.add( 'center' );","\t\t}","\t\telse {","\t\t\tdom.wrapper.classList.remove( 'center' );","\t\t}","","\t\t// Exit the paused mode if it was configured off","\t\tif( config.pause === false ) {","\t\t\tresume();","\t\t}","","\t\tif( config.mouseWheel ) {","\t\t\tdocument.addEventListener( 'DOMMouseScroll', onDocumentMouseScroll, false ); // FF","\t\t\tdocument.addEventListener( 'mousewheel', onDocumentMouseScroll, false );","\t\t}","\t\telse {","\t\t\tdocument.removeEventListener( 'DOMMouseScroll', onDocumentMouseScroll, false ); // FF","\t\t\tdocument.removeEventListener( 'mousewheel', onDocumentMouseScroll, false );","\t\t}","","\t\t// Rolling 3D links","\t\tif( config.rollingLinks ) {","\t\t\tenableRollingLinks();","\t\t}","\t\telse {","\t\t\tdisableRollingLinks();","\t\t}","","\t\t// Iframe link previews","\t\tif( config.previewLinks ) {","\t\t\tenablePreviewLinks();","\t\t}","\t\telse {","\t\t\tdisablePreviewLinks();","\t\t\tenablePreviewLinks( '[data-preview-link]' );","\t\t}","","\t\t// Remove existing auto-slide controls","\t\tif( autoSlidePlayer ) {","\t\t\tautoSlidePlayer.destroy();","\t\t\tautoSlidePlayer = null;","\t\t}","","\t\t// Generate auto-slide controls if needed","\t\tif( numberOfSlides > 1 && config.autoSlide && config.autoSlideStoppable && features.canvas && features.requestAnimationFrame ) {","\t\t\tautoSlidePlayer = new Playback( dom.wrapper, function() {","\t\t\t\treturn Math.min( Math.max( ( Date.now() - autoSlideStartTime ) / autoSlide, 0 ), 1 );","\t\t\t} );","","\t\t\tautoSlidePlayer.on( 'click', onAutoSlidePlayerClick );","\t\t\tautoSlidePaused = false;","\t\t}","","\t\t// When fragments are turned off they should be visible","\t\tif( config.fragments === false ) {","\t\t\ttoArray( dom.slides.querySelectorAll( '.fragment' ) ).forEach( function( element ) {","\t\t\t\telement.classList.add( 'visible' );","\t\t\t\telement.classList.remove( 'current-fragment' );","\t\t\t} );","\t\t}","","\t\tsync();","","\t}","","\t/**","\t * Binds all event listeners.","\t */","\tfunction addEventListeners() {","","\t\teventsAreBound = true;","","\t\twindow.addEventListener( 'hashchange', onWindowHashChange, false );","\t\twindow.addEventListener( 'resize', onWindowResize, false );","","\t\tif( config.touch ) {","\t\t\tdom.wrapper.addEventListener( 'touchstart', onTouchStart, false );","\t\t\tdom.wrapper.addEventListener( 'touchmove', onTouchMove, false );","\t\t\tdom.wrapper.addEventListener( 'touchend', onTouchEnd, false );","","\t\t\t// Support pointer-style touch interaction as well","\t\t\tif( window.navigator.pointerEnabled ) {","\t\t\t\t// IE 11 uses un-prefixed version of pointer events","\t\t\t\tdom.wrapper.addEventListener( 'pointerdown', onPointerDown, false );","\t\t\t\tdom.wrapper.addEventListener( 'pointermove', onPointerMove, false );","\t\t\t\tdom.wrapper.addEventListener( 'pointerup', onPointerUp, false );","\t\t\t}","\t\t\telse if( window.navigator.msPointerEnabled ) {","\t\t\t\t// IE 10 uses prefixed version of pointer events","\t\t\t\tdom.wrapper.addEventListener( 'MSPointerDown', onPointerDown, false );","\t\t\t\tdom.wrapper.addEventListener( 'MSPointerMove', onPointerMove, false );","\t\t\t\tdom.wrapper.addEventListener( 'MSPointerUp', onPointerUp, false );","\t\t\t}","\t\t}","","\t\tif( config.keyboard ) {","\t\t\tdocument.addEventListener( 'keydown', onDocumentKeyDown, false );","\t\t\tdocument.addEventListener( 'keypress', onDocumentKeyPress, false );","\t\t}","","\t\tif( config.progress && dom.progress ) {","\t\t\tdom.progress.addEventListener( 'click', onProgressClicked, false );","\t\t}","","\t\tif( config.focusBodyOnPageVisibilityChange ) {","\t\t\tvar visibilityChange;","","\t\t\tif( 'hidden' in document ) {","\t\t\t\tvisibilityChange = 'visibilitychange';","\t\t\t}","\t\t\telse if( 'msHidden' in document ) {","\t\t\t\tvisibilityChange = 'msvisibilitychange';","\t\t\t}","\t\t\telse if( 'webkitHidden' in document ) {","\t\t\t\tvisibilityChange = 'webkitvisibilitychange';","\t\t\t}","","\t\t\tif( visibilityChange ) {","\t\t\t\tdocument.addEventListener( visibilityChange, onPageVisibilityChange, false );","\t\t\t}","\t\t}","","\t\t// Listen to both touch and click events, in case the device","\t\t// supports both","\t\tvar pointerEvents = [ 'touchstart', 'click' ];","","\t\t// Only support touch for Android, fixes double navigations in","\t\t// stock browser","\t\tif( navigator.userAgent.match( /android/gi ) ) {","\t\t\tpointerEvents = [ 'touchstart' ];","\t\t}","","\t\tpointerEvents.forEach( function( eventName ) {","\t\t\tdom.controlsLeft.forEach( function( el ) { el.addEventListener( eventName, onNavigateLeftClicked, false ); } );","\t\t\tdom.controlsRight.forEach( function( el ) { el.addEventListener( eventName, onNavigateRightClicked, false ); } );","\t\t\tdom.controlsUp.forEach( function( el ) { el.addEventListener( eventName, onNavigateUpClicked, false ); } );","\t\t\tdom.controlsDown.forEach( function( el ) { el.addEventListener( eventName, onNavigateDownClicked, false ); } );","\t\t\tdom.controlsPrev.forEach( function( el ) { el.addEventListener( eventName, onNavigatePrevClicked, false ); } );","\t\t\tdom.controlsNext.forEach( function( el ) { el.addEventListener( eventName, onNavigateNextClicked, false ); } );","\t\t} );","","\t}","","\t/**","\t * Unbinds all event listeners.","\t */","\tfunction removeEventListeners() {","","\t\teventsAreBound = false;","","\t\tdocument.removeEventListener( 'keydown', onDocumentKeyDown, false );","\t\tdocument.removeEventListener( 'keypress', onDocumentKeyPress, false );","\t\twindow.removeEventListener( 'hashchange', onWindowHashChange, false );","\t\twindow.removeEventListener( 'resize', onWindowResize, false );","","\t\tdom.wrapper.removeEventListener( 'touchstart', onTouchStart, false );","\t\tdom.wrapper.removeEventListener( 'touchmove', onTouchMove, false );","\t\tdom.wrapper.removeEventListener( 'touchend', onTouchEnd, false );","","\t\t// IE11","\t\tif( window.navigator.pointerEnabled ) {","\t\t\tdom.wrapper.removeEventListener( 'pointerdown', onPointerDown, false );","\t\t\tdom.wrapper.removeEventListener( 'pointermove', onPointerMove, false );","\t\t\tdom.wrapper.removeEventListener( 'pointerup', onPointerUp, false );","\t\t}","\t\t// IE10","\t\telse if( window.navigator.msPointerEnabled ) {","\t\t\tdom.wrapper.removeEventListener( 'MSPointerDown', onPointerDown, false );","\t\t\tdom.wrapper.removeEventListener( 'MSPointerMove', onPointerMove, false );","\t\t\tdom.wrapper.removeEventListener( 'MSPointerUp', onPointerUp, false );","\t\t}","","\t\tif ( config.progress && dom.progress ) {","\t\t\tdom.progress.removeEventListener( 'click', onProgressClicked, false );","\t\t}","","\t\t[ 'touchstart', 'click' ].forEach( function( eventName ) {","\t\t\tdom.controlsLeft.forEach( function( el ) { el.removeEventListener( eventName, onNavigateLeftClicked, false ); } );","\t\t\tdom.controlsRight.forEach( function( el ) { el.removeEventListener( eventName, onNavigateRightClicked, false ); } );","\t\t\tdom.controlsUp.forEach( function( el ) { el.removeEventListener( eventName, onNavigateUpClicked, false ); } );","\t\t\tdom.controlsDown.forEach( function( el ) { el.removeEventListener( eventName, onNavigateDownClicked, false ); } );","\t\t\tdom.controlsPrev.forEach( function( el ) { el.removeEventListener( eventName, onNavigatePrevClicked, false ); } );","\t\t\tdom.controlsNext.forEach( function( el ) { el.removeEventListener( eventName, onNavigateNextClicked, false ); } );","\t\t} );","","\t}","","\t/**","\t * Extend object a with the properties of object b.","\t * If there's a conflict, object b takes precedence.","\t */","\tfunction extend( a, b ) {","","\t\tfor( var i in b ) {","\t\t\ta[ i ] = b[ i ];","\t\t}","","\t}","","\t/**","\t * Converts the target object to an array.","\t */","\tfunction toArray( o ) {","","\t\treturn Array.prototype.slice.call( o );","","\t}","","\t/**","\t * Utility for deserializing a value.","\t */","\tfunction deserialize( value ) {","","\t\tif( typeof value === 'string' ) {","\t\t\tif( value === 'null' ) return null;","\t\t\telse if( value === 'true' ) return true;","\t\t\telse if( value === 'false' ) return false;","\t\t\telse if( value.match( /^\\d+$/ ) ) return parseFloat( value );","\t\t}","","\t\treturn value;","","\t}","","\t/**","\t * Measures the distance in pixels between point a","\t * and point b.","\t *","\t * @param {Object} a point with x/y properties","\t * @param {Object} b point with x/y properties","\t */","\tfunction distanceBetween( a, b ) {","","\t\tvar dx = a.x - b.x,","\t\t\tdy = a.y - b.y;","","\t\treturn Math.sqrt( dx*dx + dy*dy );","","\t}","","\t/**","\t * Applies a CSS transform to the target element.","\t */","\tfunction transformElement( element, transform ) {","","\t\telement.style.WebkitTransform = transform;","\t\telement.style.MozTransform = transform;","\t\telement.style.msTransform = transform;","\t\telement.style.OTransform = transform;","\t\telement.style.transform = transform;","","\t}","","\t/**","\t * Injects the given CSS styles into the DOM.","\t */","\tfunction injectStyleSheet( value ) {","","\t\tvar tag = document.createElement( 'style' );","\t\ttag.type = 'text/css';","\t\tif( tag.styleSheet ) {","\t\t\ttag.styleSheet.cssText = value;","\t\t}","\t\telse {","\t\t\ttag.appendChild( document.createTextNode( value ) );","\t\t}","\t\tdocument.getElementsByTagName( 'head' )[0].appendChild( tag );","","\t}","","\t/**","\t * Measures the distance in pixels between point a and point b.","\t *","\t * @param {String} color The string representation of a color,","\t * the following formats are supported:","\t * - #000","\t * - #000000","\t * - rgb(0,0,0)","\t */","\tfunction colorToRgb( color ) {","","\t\tvar hex3 = color.match( /^#([0-9a-f]{3})$/i );","\t\tif( hex3 && hex3[1] ) {","\t\t\thex3 = hex3[1];","\t\t\treturn {","\t\t\t\tr: parseInt( hex3.charAt( 0 ), 16 ) * 0x11,","\t\t\t\tg: parseInt( hex3.charAt( 1 ), 16 ) * 0x11,","\t\t\t\tb: parseInt( hex3.charAt( 2 ), 16 ) * 0x11","\t\t\t};","\t\t}","","\t\tvar hex6 = color.match( /^#([0-9a-f]{6})$/i );","\t\tif( hex6 && hex6[1] ) {","\t\t\thex6 = hex6[1];","\t\t\treturn {","\t\t\t\tr: parseInt( hex6.substr( 0, 2 ), 16 ),","\t\t\t\tg: parseInt( hex6.substr( 2, 2 ), 16 ),","\t\t\t\tb: parseInt( hex6.substr( 4, 2 ), 16 )","\t\t\t};","\t\t}","","\t\tvar rgb = color.match( /^rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/i );","\t\tif( rgb ) {","\t\t\treturn {","\t\t\t\tr: parseInt( rgb[1], 10 ),","\t\t\t\tg: parseInt( rgb[2], 10 ),","\t\t\t\tb: parseInt( rgb[3], 10 )","\t\t\t};","\t\t}","","\t\tvar rgba = color.match( /^rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\,\\s*([\\d]+|[\\d]*.[\\d]+)\\s*\\)$/i );","\t\tif( rgba ) {","\t\t\treturn {","\t\t\t\tr: parseInt( rgba[1], 10 ),","\t\t\t\tg: parseInt( rgba[2], 10 ),","\t\t\t\tb: parseInt( rgba[3], 10 ),","\t\t\t\ta: parseFloat( rgba[4] )","\t\t\t};","\t\t}","","\t\treturn null;","","\t}","","\t/**","\t * Calculates brightness on a scale of 0-255.","\t *","\t * @param color See colorStringToRgb for supported formats.","\t */","\tfunction colorBrightness( color ) {","","\t\tif( typeof color === 'string' ) color = colorToRgb( color );","","\t\tif( color ) {","\t\t\treturn ( color.r * 299 + color.g * 587 + color.b * 114 ) / 1000;","\t\t}","","\t\treturn null;","","\t}","","\t/**","\t * Retrieves the height of the given element by looking","\t * at the position and height of its immediate children.","\t */","\tfunction getAbsoluteHeight( element ) {","","\t\tvar height = 0;","","\t\tif( element ) {","\t\t\tvar absoluteChildren = 0;","","\t\t\ttoArray( element.childNodes ).forEach( function( child ) {","","\t\t\t\tif( typeof child.offsetTop === 'number' && child.style ) {","\t\t\t\t\t// Count # of abs children","\t\t\t\t\tif( window.getComputedStyle( child ).position === 'absolute' ) {","\t\t\t\t\t\tabsoluteChildren += 1;","\t\t\t\t\t}","","\t\t\t\t\theight = Math.max( height, child.offsetTop + child.offsetHeight );","\t\t\t\t}","","\t\t\t} );","","\t\t\t// If there are no absolute children, use offsetHeight","\t\t\tif( absoluteChildren === 0 ) {","\t\t\t\theight = element.offsetHeight;","\t\t\t}","","\t\t}","","\t\treturn height;","","\t}","","\t/**","\t * Returns the remaining height within the parent of the","\t * target element.","\t *","\t * remaining height = [ configured parent height ] - [ current parent height ]","\t */","\tfunction getRemainingHeight( element, height ) {","","\t\theight = height || 0;","","\t\tif( element ) {","\t\t\tvar newHeight, oldHeight = element.style.height;","","\t\t\t// Change the .stretch element height to 0 in order find the height of all","\t\t\t// the other elements","\t\t\telement.style.height = '0px';","\t\t\tnewHeight = height - element.parentNode.offsetHeight;","","\t\t\t// Restore the old height, just in case","\t\t\telement.style.height = oldHeight + 'px';","","\t\t\treturn newHeight;","\t\t}","","\t\treturn height;","","\t}","","\t/**","\t * Checks if this instance is being used to print a PDF.","\t */","\tfunction isPrintingPDF() {","","\t\treturn ( /print-pdf/gi ).test( window.location.search );","","\t}","","\t/**","\t * Hides the address bar if we're on a mobile device.","\t */","\tfunction hideAddressBar() {","","\t\tif( config.hideAddressBar && isMobileDevice ) {","\t\t\t// Events that should trigger the address bar to hide","\t\t\twindow.addEventListener( 'load', removeAddressBar, false );","\t\t\twindow.addEventListener( 'orientationchange', removeAddressBar, false );","\t\t}","","\t}","","\t/**","\t * Causes the address bar to hide on mobile devices,","\t * more vertical space ftw.","\t */","\tfunction removeAddressBar() {","","\t\tsetTimeout( function() {","\t\t\twindow.scrollTo( 0, 1 );","\t\t}, 10 );","","\t}","","\t/**","\t * Dispatches an event of the specified type from the","\t * reveal DOM element.","\t */","\tfunction dispatchEvent( type, args ) {","","\t\tvar event = document.createEvent( 'HTMLEvents', 1, 2 );","\t\tevent.initEvent( type, true, true );","\t\textend( event, args );","\t\tdom.wrapper.dispatchEvent( event );","","\t\t// If we're in an iframe, post each reveal.js event to the","\t\t// parent window. Used by the notes plugin","\t\tif( config.postMessageEvents && window.parent !== window.self ) {","\t\t\twindow.parent.postMessage( JSON.stringify({ namespace: 'reveal', eventName: type, state: getState() }), '*' );","\t\t}","","\t}","","\t/**","\t * Wrap all links in 3D goodness.","\t */","\tfunction enableRollingLinks() {","","\t\tif( features.transforms3d && !( 'msPerspective' in document.body.style ) ) {","\t\t\tvar anchors = dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' a' );","","\t\t\tfor( var i = 0, len = anchors.length; i < len; i++ ) {","\t\t\t\tvar anchor = anchors[i];","","\t\t\t\tif( anchor.textContent && !anchor.querySelector( '*' ) && ( !anchor.className || !anchor.classList.contains( anchor, 'roll' ) ) ) {","\t\t\t\t\tvar span = document.createElement('span');","\t\t\t\t\tspan.setAttribute('data-title', anchor.text);","\t\t\t\t\tspan.innerHTML = anchor.innerHTML;","","\t\t\t\t\tanchor.classList.add( 'roll' );","\t\t\t\t\tanchor.innerHTML = '';","\t\t\t\t\tanchor.appendChild(span);","\t\t\t\t}","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Unwrap all 3D links.","\t */","\tfunction disableRollingLinks() {","","\t\tvar anchors = dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' a.roll' );","","\t\tfor( var i = 0, len = anchors.length; i < len; i++ ) {","\t\t\tvar anchor = anchors[i];","\t\t\tvar span = anchor.querySelector( 'span' );","","\t\t\tif( span ) {","\t\t\t\tanchor.classList.remove( 'roll' );","\t\t\t\tanchor.innerHTML = span.innerHTML;","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Bind preview frame links.","\t */","\tfunction enablePreviewLinks( selector ) {","","\t\tvar anchors = toArray( document.querySelectorAll( selector ? selector : 'a' ) );","","\t\tanchors.forEach( function( element ) {","\t\t\tif( /^(http|www)/gi.test( element.getAttribute( 'href' ) ) ) {","\t\t\t\telement.addEventListener( 'click', onPreviewLinkClicked, false );","\t\t\t}","\t\t} );","","\t}","","\t/**","\t * Unbind preview frame links.","\t */","\tfunction disablePreviewLinks() {","","\t\tvar anchors = toArray( document.querySelectorAll( 'a' ) );","","\t\tanchors.forEach( function( element ) {","\t\t\tif( /^(http|www)/gi.test( element.getAttribute( 'href' ) ) ) {","\t\t\t\telement.removeEventListener( 'click', onPreviewLinkClicked, false );","\t\t\t}","\t\t} );","","\t}","","\t/**","\t * Opens a preview window for the target URL.","\t */","\tfunction showPreview( url ) {","","\t\tcloseOverlay();","","\t\tdom.overlay = document.createElement( 'div' );","\t\tdom.overlay.classList.add( 'overlay' );","\t\tdom.overlay.classList.add( 'overlay-preview' );","\t\tdom.wrapper.appendChild( dom.overlay );","","\t\tdom.overlay.innerHTML = [","\t\t\t'<header>',","\t\t\t\t'<a class=\"close\" href=\"#\"><span class=\"icon\"></span></a>',","\t\t\t\t'<a class=\"external\" href=\"'+ url +'\" target=\"_blank\"><span class=\"icon\"></span></a>',","\t\t\t'</header>',","\t\t\t'<div class=\"spinner\"></div>',","\t\t\t'<div class=\"viewport\">',","\t\t\t\t'<iframe src=\"'+ url +'\"></iframe>',","\t\t\t'</div>'","\t\t].join('');","","\t\tdom.overlay.querySelector( 'iframe' ).addEventListener( 'load', function( event ) {","\t\t\tdom.overlay.classList.add( 'loaded' );","\t\t}, false );","","\t\tdom.overlay.querySelector( '.close' ).addEventListener( 'click', function( event ) {","\t\t\tcloseOverlay();","\t\t\tevent.preventDefault();","\t\t}, false );","","\t\tdom.overlay.querySelector( '.external' ).addEventListener( 'click', function( event ) {","\t\t\tcloseOverlay();","\t\t}, false );","","\t\tsetTimeout( function() {","\t\t\tdom.overlay.classList.add( 'visible' );","\t\t}, 1 );","","\t}","","\t/**","\t * Opens a overlay window with help material.","\t */","\tfunction showHelp() {","","\t\tif( config.help ) {","","\t\t\tcloseOverlay();","","\t\t\tdom.overlay = document.createElement( 'div' );","\t\t\tdom.overlay.classList.add( 'overlay' );","\t\t\tdom.overlay.classList.add( 'overlay-help' );","\t\t\tdom.wrapper.appendChild( dom.overlay );","","\t\t\tvar html = '<p class=\"title\">Keyboard Shortcuts</p><br/>';","","\t\t\thtml += '<table><th>KEY</th><th>ACTION</th>';","\t\t\tfor( var key in keyboardShortcuts ) {","\t\t\t\thtml += '<tr><td>' + key + '</td><td>' + keyboardShortcuts[ key ] + '</td></tr>';","\t\t\t}","","\t\t\thtml += '</table>';","","\t\t\tdom.overlay.innerHTML = [","\t\t\t\t'<header>',","\t\t\t\t\t'<a class=\"close\" href=\"#\"><span class=\"icon\"></span></a>',","\t\t\t\t'</header>',","\t\t\t\t'<div class=\"viewport\">',","\t\t\t\t\t'<div class=\"viewport-inner\">'+ html +'</div>',","\t\t\t\t'</div>'","\t\t\t].join('');","","\t\t\tdom.overlay.querySelector( '.close' ).addEventListener( 'click', function( event ) {","\t\t\t\tcloseOverlay();","\t\t\t\tevent.preventDefault();","\t\t\t}, false );","","\t\t\tsetTimeout( function() {","\t\t\t\tdom.overlay.classList.add( 'visible' );","\t\t\t}, 1 );","","\t\t}","","\t}","","\t/**","\t * Closes any currently open overlay.","\t */","\tfunction closeOverlay() {","","\t\tif( dom.overlay ) {","\t\t\tdom.overlay.parentNode.removeChild( dom.overlay );","\t\t\tdom.overlay = null;","\t\t}","","\t}","","\t/**","\t * Applies JavaScript-controlled layout rules to the","\t * presentation.","\t */","\tfunction layout() {","","\t\tif( dom.wrapper && !isPrintingPDF() ) {","","\t\t\tvar size = getComputedSlideSize();","","\t\t\tvar slidePadding = 20; // TODO Dig this out of DOM","","\t\t\t// Layout the contents of the slides","\t\t\tlayoutSlideContents( config.width, config.height, slidePadding );","","\t\t\tdom.slides.style.width = size.width + 'px';","\t\t\tdom.slides.style.height = size.height + 'px';","","\t\t\t// Determine scale of content to fit within available space","\t\t\tscale = Math.min( size.presentationWidth / size.width, size.presentationHeight / size.height );","","\t\t\t// Respect max/min scale settings","\t\t\tscale = Math.max( scale, config.minScale );","\t\t\tscale = Math.min( scale, config.maxScale );","","\t\t\t// Don't apply any scaling styles if scale is 1","\t\t\tif( scale === 1 ) {","\t\t\t\tdom.slides.style.zoom = '';","\t\t\t\tdom.slides.style.left = '';","\t\t\t\tdom.slides.style.top = '';","\t\t\t\tdom.slides.style.bottom = '';","\t\t\t\tdom.slides.style.right = '';","\t\t\t\ttransformElement( dom.slides, '' );","\t\t\t}","\t\t\telse {","\t\t\t\t// Prefer zooming in desktop Chrome so that content remains crisp","\t\t\t\tif( !isMobileDevice && /chrome/i.test( navigator.userAgent ) && typeof dom.slides.style.zoom !== 'undefined' ) {","\t\t\t\t\tdom.slides.style.zoom = scale;","\t\t\t\t}","\t\t\t\t// Apply scale transform as a fallback","\t\t\t\telse {","\t\t\t\t\tdom.slides.style.left = '50%';","\t\t\t\t\tdom.slides.style.top = '50%';","\t\t\t\t\tdom.slides.style.bottom = 'auto';","\t\t\t\t\tdom.slides.style.right = 'auto';","\t\t\t\t\ttransformElement( dom.slides, 'translate(-50%, -50%) scale('+ scale +')' );","\t\t\t\t}","\t\t\t}","","\t\t\t// Select all slides, vertical and horizontal","\t\t\tvar slides = toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) );","","\t\t\tfor( var i = 0, len = slides.length; i < len; i++ ) {","\t\t\t\tvar slide = slides[ i ];","","\t\t\t\t// Don't bother updating invisible slides","\t\t\t\tif( slide.style.display === 'none' ) {","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\tif( config.center || slide.classList.contains( 'center' ) ) {","\t\t\t\t\t// Vertical stacks are not centred since their section","\t\t\t\t\t// children will be","\t\t\t\t\tif( slide.classList.contains( 'stack' ) ) {","\t\t\t\t\t\tslide.style.top = 0;","\t\t\t\t\t}","\t\t\t\t\telse {","\t\t\t\t\t\tslide.style.top = Math.max( ( ( size.height - getAbsoluteHeight( slide ) ) / 2 ) - slidePadding, 0 ) + 'px';","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\tslide.style.top = '';","\t\t\t\t}","","\t\t\t}","","\t\t\tupdateProgress();","\t\t\tupdateParallax();","","\t\t}","","\t}","","\t/**","\t * Applies layout logic to the contents of all slides in","\t * the presentation.","\t */","\tfunction layoutSlideContents( width, height, padding ) {","","\t\t// Handle sizing of elements with the 'stretch' class","\t\ttoArray( dom.slides.querySelectorAll( 'section > .stretch' ) ).forEach( function( element ) {","","\t\t\t// Determine how much vertical space we can use","\t\t\tvar remainingHeight = getRemainingHeight( element, height );","","\t\t\t// Consider the aspect ratio of media elements","\t\t\tif( /(img|video)/gi.test( element.nodeName ) ) {","\t\t\t\tvar nw = element.naturalWidth || element.videoWidth,","\t\t\t\t\tnh = element.naturalHeight || element.videoHeight;","","\t\t\t\tvar es = Math.min( width / nw, remainingHeight / nh );","","\t\t\t\telement.style.width = ( nw * es ) + 'px';","\t\t\t\telement.style.height = ( nh * es ) + 'px';","","\t\t\t}","\t\t\telse {","\t\t\t\telement.style.width = width + 'px';","\t\t\t\telement.style.height = remainingHeight + 'px';","\t\t\t}","","\t\t} );","","\t}","","\t/**","\t * Calculates the computed pixel size of our slides. These","\t * values are based on the width and height configuration","\t * options.","\t */","\tfunction getComputedSlideSize( presentationWidth, presentationHeight ) {","","\t\tvar size = {","\t\t\t// Slide size","\t\t\twidth: config.width,","\t\t\theight: config.height,","","\t\t\t// Presentation size","\t\t\tpresentationWidth: presentationWidth || dom.wrapper.offsetWidth,","\t\t\tpresentationHeight: presentationHeight || dom.wrapper.offsetHeight","\t\t};","","\t\t// Reduce available space by margin","\t\tsize.presentationWidth -= ( size.presentationHeight * config.margin );","\t\tsize.presentationHeight -= ( size.presentationHeight * config.margin );","","\t\t// Slide width may be a percentage of available width","\t\tif( typeof size.width === 'string' && /%$/.test( size.width ) ) {","\t\t\tsize.width = parseInt( size.width, 10 ) / 100 * size.presentationWidth;","\t\t}","","\t\t// Slide height may be a percentage of available height","\t\tif( typeof size.height === 'string' && /%$/.test( size.height ) ) {","\t\t\tsize.height = parseInt( size.height, 10 ) / 100 * size.presentationHeight;","\t\t}","","\t\treturn size;","","\t}","","\t/**","\t * Stores the vertical index of a stack so that the same","\t * vertical slide can be selected when navigating to and","\t * from the stack.","\t *","\t * @param {HTMLElement} stack The vertical stack element","\t * @param {int} v Index to memorize","\t */","\tfunction setPreviousVerticalIndex( stack, v ) {","","\t\tif( typeof stack === 'object' && typeof stack.setAttribute === 'function' ) {","\t\t\tstack.setAttribute( 'data-previous-indexv', v || 0 );","\t\t}","","\t}","","\t/**","\t * Retrieves the vertical index which was stored using","\t * #setPreviousVerticalIndex() or 0 if no previous index","\t * exists.","\t *","\t * @param {HTMLElement} stack The vertical stack element","\t */","\tfunction getPreviousVerticalIndex( stack ) {","","\t\tif( typeof stack === 'object' && typeof stack.setAttribute === 'function' && stack.classList.contains( 'stack' ) ) {","\t\t\t// Prefer manually defined start-indexv","\t\t\tvar attributeName = stack.hasAttribute( 'data-start-indexv' ) ? 'data-start-indexv' : 'data-previous-indexv';","","\t\t\treturn parseInt( stack.getAttribute( attributeName ) || 0, 10 );","\t\t}","","\t\treturn 0;","","\t}","","\t/**","\t * Displays the overview of slides (quick nav) by","\t * scaling down and arranging all slide elements.","\t *","\t * Experimental feature, might be dropped if perf","\t * can't be improved.","\t */","\tfunction activateOverview() {","","\t\t// Only proceed if enabled in config","\t\tif( config.overview ) {","","\t\t\t// Don't auto-slide while in overview mode","\t\t\tcancelAutoSlide();","","\t\t\tvar wasActive = dom.wrapper.classList.contains( 'overview' );","","\t\t\t// Vary the depth of the overview based on screen size","\t\t\tvar depth = window.innerWidth < 400 ? 1000 : 2500;","","\t\t\tdom.wrapper.classList.add( 'overview' );","\t\t\tdom.wrapper.classList.remove( 'overview-deactivating' );","","\t\t\tvar horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR );","","\t\t\tfor( var i = 0, len1 = horizontalSlides.length; i < len1; i++ ) {","\t\t\t\tvar hslide = horizontalSlides[i],","\t\t\t\t\thoffset = config.rtl ? -105 : 105;","","\t\t\t\thslide.setAttribute( 'data-index-h', i );","","\t\t\t\t// Apply CSS transform","\t\t\t\ttransformElement( hslide, 'translateZ(-'+ depth +'px) translate(' + ( ( i - indexh ) * hoffset ) + '%, 0%)' );","","\t\t\t\tif( hslide.classList.contains( 'stack' ) ) {","","\t\t\t\t\tvar verticalSlides = hslide.querySelectorAll( 'section' );","","\t\t\t\t\tfor( var j = 0, len2 = verticalSlides.length; j < len2; j++ ) {","\t\t\t\t\t\tvar verticalIndex = i === indexh ? indexv : getPreviousVerticalIndex( hslide );","","\t\t\t\t\t\tvar vslide = verticalSlides[j];","","\t\t\t\t\t\tvslide.setAttribute( 'data-index-h', i );","\t\t\t\t\t\tvslide.setAttribute( 'data-index-v', j );","","\t\t\t\t\t\t// Apply CSS transform","\t\t\t\t\t\ttransformElement( vslide, 'translate(0%, ' + ( ( j - verticalIndex ) * 105 ) + '%)' );","","\t\t\t\t\t\t// Navigate to this slide on click","\t\t\t\t\t\tvslide.addEventListener( 'click', onOverviewSlideClicked, true );","\t\t\t\t\t}","","\t\t\t\t}","\t\t\t\telse {","","\t\t\t\t\t// Navigate to this slide on click","\t\t\t\t\thslide.addEventListener( 'click', onOverviewSlideClicked, true );","","\t\t\t\t}","\t\t\t}","","\t\t\tupdateSlidesVisibility();","","\t\t\tlayout();","","\t\t\tif( !wasActive ) {","\t\t\t\t// Notify observers of the overview showing","\t\t\t\tdispatchEvent( 'overviewshown', {","\t\t\t\t\t'indexh': indexh,","\t\t\t\t\t'indexv': indexv,","\t\t\t\t\t'currentSlide': currentSlide","\t\t\t\t} );","\t\t\t}","","\t\t}","","\t}","","\t/**","\t * Exits the slide overview and enters the currently","\t * active slide.","\t */","\tfunction deactivateOverview() {","","\t\t// Only proceed if enabled in config","\t\tif( config.overview ) {","","\t\t\tdom.wrapper.classList.remove( 'overview' );","","\t\t\t// Temporarily add a class so that transitions can do different things","\t\t\t// depending on whether they are exiting/entering overview, or just","\t\t\t// moving from slide to slide","\t\t\tdom.wrapper.classList.add( 'overview-deactivating' );","","\t\t\tsetTimeout( function () {","\t\t\t\tdom.wrapper.classList.remove( 'overview-deactivating' );","\t\t\t}, 1 );","","\t\t\t// Select all slides","\t\t\ttoArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {","\t\t\t\t// Resets all transforms to use the external styles","\t\t\t\ttransformElement( slide, '' );","","\t\t\t\tslide.removeEventListener( 'click', onOverviewSlideClicked, true );","\t\t\t} );","","\t\t\tslide( indexh, indexv );","","\t\t\tcueAutoSlide();","","\t\t\t// Notify observers of the overview hiding","\t\t\tdispatchEvent( 'overviewhidden', {","\t\t\t\t'indexh': indexh,","\t\t\t\t'indexv': indexv,","\t\t\t\t'currentSlide': currentSlide","\t\t\t} );","","\t\t}","\t}","","\t/**","\t * Toggles the slide overview mode on and off.","\t *","\t * @param {Boolean} override Optional flag which overrides the","\t * toggle logic and forcibly sets the desired state. True means","\t * overview is open, false means it's closed.","\t */","\tfunction toggleOverview( override ) {","","\t\tif( typeof override === 'boolean' ) {","\t\t\toverride ? activateOverview() : deactivateOverview();","\t\t}","\t\telse {","\t\t\tisOverview() ? deactivateOverview() : activateOverview();","\t\t}","","\t}","","\t/**","\t * Checks if the overview is currently active.","\t *","\t * @return {Boolean} true if the overview is active,","\t * false otherwise","\t */","\tfunction isOverview() {","","\t\treturn dom.wrapper.classList.contains( 'overview' );","","\t}","","\t/**","\t * Checks if the current or specified slide is vertical","\t * (nested within another slide).","\t *","\t * @param {HTMLElement} slide [optional] The slide to check","\t * orientation of","\t */","\tfunction isVerticalSlide( slide ) {","","\t\t// Prefer slide argument, otherwise use current slide","\t\tslide = slide ? slide : currentSlide;","","\t\treturn slide && slide.parentNode && !!slide.parentNode.nodeName.match( /section/i );","","\t}","","\t/**","\t * Handling the fullscreen functionality via the fullscreen API","\t *","\t * @see http://fullscreen.spec.whatwg.org/","\t * @see https://developer.mozilla.org/en-US/docs/DOM/Using_fullscreen_mode","\t */","\tfunction enterFullscreen() {","","\t\tvar element = document.body;","","\t\t// Check which implementation is available","\t\tvar requestMethod = element.requestFullScreen ||","\t\t\t\t\t\t\telement.webkitRequestFullscreen ||","\t\t\t\t\t\t\telement.webkitRequestFullScreen ||","\t\t\t\t\t\t\telement.mozRequestFullScreen ||","\t\t\t\t\t\t\telement.msRequestFullscreen;","","\t\tif( requestMethod ) {","\t\t\trequestMethod.apply( element );","\t\t}","","\t}","","\t/**","\t * Enters the paused mode which fades everything on screen to","\t * black.","\t */","\tfunction pause() {","","\t\tif( config.pause ) {","\t\t\tvar wasPaused = dom.wrapper.classList.contains( 'paused' );","","\t\t\tcancelAutoSlide();","\t\t\tdom.wrapper.classList.add( 'paused' );","","\t\t\tif( wasPaused === false ) {","\t\t\t\tdispatchEvent( 'paused' );","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Exits from the paused mode.","\t */","\tfunction resume() {","","\t\tvar wasPaused = dom.wrapper.classList.contains( 'paused' );","\t\tdom.wrapper.classList.remove( 'paused' );","","\t\tcueAutoSlide();","","\t\tif( wasPaused ) {","\t\t\tdispatchEvent( 'resumed' );","\t\t}","","\t}","","\t/**","\t * Toggles the paused mode on and off.","\t */","\tfunction togglePause( override ) {","","\t\tif( typeof override === 'boolean' ) {","\t\t\toverride ? pause() : resume();","\t\t}","\t\telse {","\t\t\tisPaused() ? resume() : pause();","\t\t}","","\t}","","\t/**","\t * Checks if we are currently in the paused mode.","\t */","\tfunction isPaused() {","","\t\treturn dom.wrapper.classList.contains( 'paused' );","","\t}","","\t/**","\t * Toggles the auto slide mode on and off.","\t *","\t * @param {Boolean} override Optional flag which sets the desired state.","\t * True means autoplay starts, false means it stops.","\t */","","\tfunction toggleAutoSlide( override ) {","","\t\tif( typeof override === 'boolean' ) {","\t\t\toverride ? resumeAutoSlide() : pauseAutoSlide();","\t\t}","","\t\telse {","\t\t\tautoSlidePaused ? resumeAutoSlide() : pauseAutoSlide();","\t\t}","","\t}","","\t/**","\t * Checks if the auto slide mode is currently on.","\t */","\tfunction isAutoSliding() {","","\t\treturn !!( autoSlide && !autoSlidePaused );","","\t}","","\t/**","\t * Steps from the current point in the presentation to the","\t * slide which matches the specified horizontal and vertical","\t * indices.","\t *","\t * @param {int} h Horizontal index of the target slide","\t * @param {int} v Vertical index of the target slide","\t * @param {int} f Optional index of a fragment within the","\t * target slide to activate","\t * @param {int} o Optional origin for use in multimaster environments","\t */","\tfunction slide( h, v, f, o ) {","","\t\t// Remember where we were at before","\t\tpreviousSlide = currentSlide;","","\t\t// Query all horizontal slides in the deck","\t\tvar horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR );","","\t\t// If no vertical index is specified and the upcoming slide is a","\t\t// stack, resume at its previous vertical index","\t\tif( v === undefined ) {","\t\t\tv = getPreviousVerticalIndex( horizontalSlides[ h ] );","\t\t}","","\t\t// If we were on a vertical stack, remember what vertical index","\t\t// it was on so we can resume at the same position when returning","\t\tif( previousSlide && previousSlide.parentNode && previousSlide.parentNode.classList.contains( 'stack' ) ) {","\t\t\tsetPreviousVerticalIndex( previousSlide.parentNode, indexv );","\t\t}","","\t\t// Remember the state before this slide","\t\tvar stateBefore = state.concat();","","\t\t// Reset the state array","\t\tstate.length = 0;","","\t\tvar indexhBefore = indexh || 0,","\t\t\tindexvBefore = indexv || 0;","","\t\t// Activate and transition to the new slide","\t\tindexh = updateSlides( HORIZONTAL_SLIDES_SELECTOR, h === undefined ? indexh : h );","\t\tindexv = updateSlides( VERTICAL_SLIDES_SELECTOR, v === undefined ? indexv : v );","","\t\t// Update the visibility of slides now that the indices have changed","\t\tupdateSlidesVisibility();","","\t\tlayout();","","\t\t// Apply the new state","\t\tstateLoop: for( var i = 0, len = state.length; i < len; i++ ) {","\t\t\t// Check if this state existed on the previous slide. If it","\t\t\t// did, we will avoid adding it repeatedly","\t\t\tfor( var j = 0; j < stateBefore.length; j++ ) {","\t\t\t\tif( stateBefore[j] === state[i] ) {","\t\t\t\t\tstateBefore.splice( j, 1 );","\t\t\t\t\tcontinue stateLoop;","\t\t\t\t}","\t\t\t}","","\t\t\tdocument.documentElement.classList.add( state[i] );","","\t\t\t// Dispatch custom event matching the state's name","\t\t\tdispatchEvent( state[i] );","\t\t}","","\t\t// Clean up the remains of the previous state","\t\twhile( stateBefore.length ) {","\t\t\tdocument.documentElement.classList.remove( stateBefore.pop() );","\t\t}","","\t\t// If the overview is active, re-activate it to update positions","\t\tif( isOverview() ) {","\t\t\tactivateOverview();","\t\t}","","\t\t// Find the current horizontal slide and any possible vertical slides","\t\t// within it","\t\tvar currentHorizontalSlide = horizontalSlides[ indexh ],","\t\t\tcurrentVerticalSlides = currentHorizontalSlide.querySelectorAll( 'section' );","","\t\t// Store references to the previous and current slides","\t\tcurrentSlide = currentVerticalSlides[ indexv ] || currentHorizontalSlide;","","\t\t// Show fragment, if specified","\t\tif( typeof f !== 'undefined' ) {","\t\t\tnavigateFragment( f );","\t\t}","","\t\t// Dispatch an event if the slide changed","\t\tvar slideChanged = ( indexh !== indexhBefore || indexv !== indexvBefore );","\t\tif( slideChanged ) {","\t\t\tdispatchEvent( 'slidechanged', {","\t\t\t\t'indexh': indexh,","\t\t\t\t'indexv': indexv,","\t\t\t\t'previousSlide': previousSlide,","\t\t\t\t'currentSlide': currentSlide,","\t\t\t\t'origin': o","\t\t\t} );","\t\t}","\t\telse {","\t\t\t// Ensure that the previous slide is never the same as the current","\t\t\tpreviousSlide = null;","\t\t}","","\t\t// Solves an edge case where the previous slide maintains the","\t\t// 'present' class when navigating between adjacent vertical","\t\t// stacks","\t\tif( previousSlide ) {","\t\t\tpreviousSlide.classList.remove( 'present' );","\t\t\tpreviousSlide.setAttribute( 'aria-hidden', 'true' );","","\t\t\t// Reset all slides upon navigate to home","\t\t\t// Issue: #285","\t\t\tif ( dom.wrapper.querySelector( HOME_SLIDE_SELECTOR ).classList.contains( 'present' ) ) {","\t\t\t\t// Launch async task","\t\t\t\tsetTimeout( function () {","\t\t\t\t\tvar slides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.stack') ), i;","\t\t\t\t\tfor( i in slides ) {","\t\t\t\t\t\tif( slides[i] ) {","\t\t\t\t\t\t\t// Reset stack","\t\t\t\t\t\t\tsetPreviousVerticalIndex( slides[i], 0 );","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}, 0 );","\t\t\t}","\t\t}","","\t\t// Handle embedded content","\t\tif( slideChanged || !previousSlide ) {","\t\t\tstopEmbeddedContent( previousSlide );","\t\t\tstartEmbeddedContent( currentSlide );","\t\t}","","\t\t// Announce the current slide contents, for screen readers","\t\tdom.statusDiv.textContent = currentSlide.textContent;","","\t\tupdateControls();","\t\tupdateProgress();","\t\tupdateBackground();","\t\tupdateParallax();","\t\tupdateSlideNumber();","","\t\t// Update the URL hash","\t\twriteURL();","","\t\tcueAutoSlide();","","\t}","","\t/**","\t * Syncs the presentation with the current DOM. Useful","\t * when new slides or control elements are added or when","\t * the configuration has changed.","\t */","\tfunction sync() {","","\t\t// Subscribe to input","\t\tremoveEventListeners();","\t\taddEventListeners();","","\t\t// Force a layout to make sure the current config is accounted for","\t\tlayout();","","\t\t// Reflect the current autoSlide value","\t\tautoSlide = config.autoSlide;","","\t\t// Start auto-sliding if it's enabled","\t\tcueAutoSlide();","","\t\t// Re-create the slide backgrounds","\t\tcreateBackgrounds();","","\t\t// Write the current hash to the URL","\t\twriteURL();","","\t\tsortAllFragments();","","\t\tupdateControls();","\t\tupdateProgress();","\t\tupdateBackground( true );","\t\tupdateSlideNumber();","\t\tupdateSlidesVisibility();","","\t\tformatEmbeddedContent();","","\t}","","\t/**","\t * Resets all vertical slides so that only the first","\t * is visible.","\t */","\tfunction resetVerticalSlides() {","","\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );","\t\thorizontalSlides.forEach( function( horizontalSlide ) {","","\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );","\t\t\tverticalSlides.forEach( function( verticalSlide, y ) {","","\t\t\t\tif( y > 0 ) {","\t\t\t\t\tverticalSlide.classList.remove( 'present' );","\t\t\t\t\tverticalSlide.classList.remove( 'past' );","\t\t\t\t\tverticalSlide.classList.add( 'future' );","\t\t\t\t\tverticalSlide.setAttribute( 'aria-hidden', 'true' );","\t\t\t\t}","","\t\t\t} );","","\t\t} );","","\t}","","\t/**","\t * Sorts and formats all of fragments in the","\t * presentation.","\t */","\tfunction sortAllFragments() {","","\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );","\t\thorizontalSlides.forEach( function( horizontalSlide ) {","","\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );","\t\t\tverticalSlides.forEach( function( verticalSlide, y ) {","","\t\t\t\tsortFragments( verticalSlide.querySelectorAll( '.fragment' ) );","","\t\t\t} );","","\t\t\tif( verticalSlides.length === 0 ) sortFragments( horizontalSlide.querySelectorAll( '.fragment' ) );","","\t\t} );","","\t}","","\t/**","\t * Updates one dimension of slides by showing the slide","\t * with the specified index.","\t *","\t * @param {String} selector A CSS selector that will fetch","\t * the group of slides we are working with","\t * @param {Number} index The index of the slide that should be","\t * shown","\t *","\t * @return {Number} The index of the slide that is now shown,","\t * might differ from the passed in index if it was out of","\t * bounds.","\t */","\tfunction updateSlides( selector, index ) {","","\t\t// Select all slides and convert the NodeList result to","\t\t// an array","\t\tvar slides = toArray( dom.wrapper.querySelectorAll( selector ) ),","\t\t\tslidesLength = slides.length;","","\t\tvar printMode = isPrintingPDF();","","\t\tif( slidesLength ) {","","\t\t\t// Should the index loop?","\t\t\tif( config.loop ) {","\t\t\t\tindex %= slidesLength;","","\t\t\t\tif( index < 0 ) {","\t\t\t\t\tindex = slidesLength + index;","\t\t\t\t}","\t\t\t}","","\t\t\t// Enforce max and minimum index bounds","\t\t\tindex = Math.max( Math.min( index, slidesLength - 1 ), 0 );","","\t\t\tfor( var i = 0; i < slidesLength; i++ ) {","\t\t\t\tvar element = slides[i];","","\t\t\t\tvar reverse = config.rtl && !isVerticalSlide( element );","","\t\t\t\telement.classList.remove( 'past' );","\t\t\t\telement.classList.remove( 'present' );","\t\t\t\telement.classList.remove( 'future' );","","\t\t\t\t// http://www.w3.org/html/wg/drafts/html/master/editing.html#the-hidden-attribute","\t\t\t\telement.setAttribute( 'hidden', '' );","\t\t\t\telement.setAttribute( 'aria-hidden', 'true' );","","\t\t\t\t// If this element contains vertical slides","\t\t\t\tif( element.querySelector( 'section' ) ) {","\t\t\t\t\telement.classList.add( 'stack' );","\t\t\t\t}","","\t\t\t\t// If we're printing static slides, all slides are \"present\"","\t\t\t\tif( printMode ) {","\t\t\t\t\telement.classList.add( 'present' );","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\tif( i < index ) {","\t\t\t\t\t// Any element previous to index is given the 'past' class","\t\t\t\t\telement.classList.add( reverse ? 'future' : 'past' );","","\t\t\t\t\tif( config.fragments ) {","\t\t\t\t\t\tvar pastFragments = toArray( element.querySelectorAll( '.fragment' ) );","","\t\t\t\t\t\t// Show all fragments on prior slides","\t\t\t\t\t\twhile( pastFragments.length ) {","\t\t\t\t\t\t\tvar pastFragment = pastFragments.pop();","\t\t\t\t\t\t\tpastFragment.classList.add( 'visible' );","\t\t\t\t\t\t\tpastFragment.classList.remove( 'current-fragment' );","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\telse if( i > index ) {","\t\t\t\t\t// Any element subsequent to index is given the 'future' class","\t\t\t\t\telement.classList.add( reverse ? 'past' : 'future' );","","\t\t\t\t\tif( config.fragments ) {","\t\t\t\t\t\tvar futureFragments = toArray( element.querySelectorAll( '.fragment.visible' ) );","","\t\t\t\t\t\t// No fragments in future slides should be visible ahead of time","\t\t\t\t\t\twhile( futureFragments.length ) {","\t\t\t\t\t\t\tvar futureFragment = futureFragments.pop();","\t\t\t\t\t\t\tfutureFragment.classList.remove( 'visible' );","\t\t\t\t\t\t\tfutureFragment.classList.remove( 'current-fragment' );","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\t// Mark the current slide as present","\t\t\tslides[index].classList.add( 'present' );","\t\t\tslides[index].removeAttribute( 'hidden' );","\t\t\tslides[index].removeAttribute( 'aria-hidden' );","","\t\t\t// If this slide has a state associated with it, add it","\t\t\t// onto the current state of the deck","\t\t\tvar slideState = slides[index].getAttribute( 'data-state' );","\t\t\tif( slideState ) {","\t\t\t\tstate = state.concat( slideState.split( ' ' ) );","\t\t\t}","","\t\t}","\t\telse {","\t\t\t// Since there are no slides we can't be anywhere beyond the","\t\t\t// zeroth index","\t\t\tindex = 0;","\t\t}","","\t\treturn index;","","\t}","","\t/**","\t * Optimization method; hide all slides that are far away","\t * from the present slide.","\t */","\tfunction updateSlidesVisibility() {","","\t\t// Select all slides and convert the NodeList result to","\t\t// an array","\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ),","\t\t\thorizontalSlidesLength = horizontalSlides.length,","\t\t\tdistanceX,","\t\t\tdistanceY;","","\t\tif( horizontalSlidesLength && typeof indexh !== 'undefined' ) {","","\t\t\t// The number of steps away from the present slide that will","\t\t\t// be visible","\t\t\tvar viewDistance = isOverview() ? 10 : config.viewDistance;","","\t\t\t// Limit view distance on weaker devices","\t\t\tif( isMobileDevice ) {","\t\t\t\tviewDistance = isOverview() ? 6 : 2;","\t\t\t}","","\t\t\t// Limit view distance on weaker devices","\t\t\tif( isPrintingPDF() ) {","\t\t\t\tviewDistance = Number.MAX_VALUE;","\t\t\t}","","\t\t\tfor( var x = 0; x < horizontalSlidesLength; x++ ) {","\t\t\t\tvar horizontalSlide = horizontalSlides[x];","","\t\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) ),","\t\t\t\t\tverticalSlidesLength = verticalSlides.length;","","\t\t\t\t// Loops so that it measures 1 between the first and last slides","\t\t\t\tdistanceX = Math.abs( ( ( indexh || 0 ) - x ) % ( horizontalSlidesLength - viewDistance ) ) || 0;","","\t\t\t\t// Show the horizontal slide if it's within the view distance","\t\t\t\tif( distanceX < viewDistance ) {","\t\t\t\t\tshowSlide( horizontalSlide );","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\thideSlide( horizontalSlide );","\t\t\t\t}","","\t\t\t\tif( verticalSlidesLength ) {","","\t\t\t\t\tvar oy = getPreviousVerticalIndex( horizontalSlide );","","\t\t\t\t\tfor( var y = 0; y < verticalSlidesLength; y++ ) {","\t\t\t\t\t\tvar verticalSlide = verticalSlides[y];","","\t\t\t\t\t\tdistanceY = x === ( indexh || 0 ) ? Math.abs( ( indexv || 0 ) - y ) : Math.abs( y - oy );","","\t\t\t\t\t\tif( distanceX + distanceY < viewDistance ) {","\t\t\t\t\t\t\tshowSlide( verticalSlide );","\t\t\t\t\t\t}","\t\t\t\t\t\telse {","\t\t\t\t\t\t\thideSlide( verticalSlide );","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t}","\t\t\t}","","\t\t}","","\t}","","\t/**","\t * Updates the progress bar to reflect the current slide.","\t */","\tfunction updateProgress() {","","\t\t// Update progress if enabled","\t\tif( config.progress && dom.progressbar ) {","","\t\t\tdom.progressbar.style.width = getProgress() * dom.wrapper.offsetWidth + 'px';","","\t\t}","","\t}","","\t/**","\t * Updates the slide number div to reflect the current slide.","\t */","\tfunction updateSlideNumber() {","","\t\t// Update slide number if enabled","\t\tif( config.slideNumber && dom.slideNumber) {","","\t\t\t// Display the number of the page using 'indexh - indexv' format","\t\t\tvar indexString = indexh;","\t\t\tif( indexv > 0 ) {","\t\t\t\tindexString += ' - ' + indexv;","\t\t\t}","","\t\t\tdom.slideNumber.innerHTML = indexString;","\t\t}","","\t}","","\t/**","\t * Updates the state of all control/navigation arrows.","\t */","\tfunction updateControls() {","","\t\tvar routes = availableRoutes();","\t\tvar fragments = availableFragments();","","\t\t// Remove the 'enabled' class from all directions","\t\tdom.controlsLeft.concat( dom.controlsRight )","\t\t\t\t\t\t.concat( dom.controlsUp )","\t\t\t\t\t\t.concat( dom.controlsDown )","\t\t\t\t\t\t.concat( dom.controlsPrev )","\t\t\t\t\t\t.concat( dom.controlsNext ).forEach( function( node ) {","\t\t\tnode.classList.remove( 'enabled' );","\t\t\tnode.classList.remove( 'fragmented' );","\t\t} );","","\t\t// Add the 'enabled' class to the available routes","\t\tif( routes.left ) dom.controlsLeft.forEach( function( el ) { el.classList.add( 'enabled' );\t} );","\t\tif( routes.right ) dom.controlsRight.forEach( function( el ) { el.classList.add( 'enabled' ); } );","\t\tif( routes.up ) dom.controlsUp.forEach( function( el ) { el.classList.add( 'enabled' );\t} );","\t\tif( routes.down ) dom.controlsDown.forEach( function( el ) { el.classList.add( 'enabled' ); } );","","\t\t// Prev/next buttons","\t\tif( routes.left || routes.up ) dom.controlsPrev.forEach( function( el ) { el.classList.add( 'enabled' ); } );","\t\tif( routes.right || routes.down ) dom.controlsNext.forEach( function( el ) { el.classList.add( 'enabled' ); } );","","\t\t// Highlight fragment directions","\t\tif( currentSlide ) {","","\t\t\t// Always apply fragment decorator to prev/next buttons","\t\t\tif( fragments.prev ) dom.controlsPrev.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); } );","\t\t\tif( fragments.next ) dom.controlsNext.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); } );","","\t\t\t// Apply fragment decorators to directional buttons based on","\t\t\t// what slide axis they are in","\t\t\tif( isVerticalSlide( currentSlide ) ) {","\t\t\t\tif( fragments.prev ) dom.controlsUp.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); } );","\t\t\t\tif( fragments.next ) dom.controlsDown.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); } );","\t\t\t}","\t\t\telse {","\t\t\t\tif( fragments.prev ) dom.controlsLeft.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); } );","\t\t\t\tif( fragments.next ) dom.controlsRight.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); } );","\t\t\t}","","\t\t}","","\t}","","\t/**","\t * Updates the background elements to reflect the current","\t * slide.","\t *","\t * @param {Boolean} includeAll If true, the backgrounds of","\t * all vertical slides (not just the present) will be updated.","\t */","\tfunction updateBackground( includeAll ) {","","\t\tvar currentBackground = null;","","\t\t// Reverse past/future classes when in RTL mode","\t\tvar horizontalPast = config.rtl ? 'future' : 'past',","\t\t\thorizontalFuture = config.rtl ? 'past' : 'future';","","\t\t// Update the classes of all backgrounds to match the","\t\t// states of their slides (past/present/future)","\t\ttoArray( dom.background.childNodes ).forEach( function( backgroundh, h ) {","","\t\t\tbackgroundh.classList.remove( 'past' );","\t\t\tbackgroundh.classList.remove( 'present' );","\t\t\tbackgroundh.classList.remove( 'future' );","","\t\t\tif( h < indexh ) {","\t\t\t\tbackgroundh.classList.add( horizontalPast );","\t\t\t}","\t\t\telse if ( h > indexh ) {","\t\t\t\tbackgroundh.classList.add( horizontalFuture );","\t\t\t}","\t\t\telse {","\t\t\t\tbackgroundh.classList.add( 'present' );","","\t\t\t\t// Store a reference to the current background element","\t\t\t\tcurrentBackground = backgroundh;","\t\t\t}","","\t\t\tif( includeAll || h === indexh ) {","\t\t\t\ttoArray( backgroundh.querySelectorAll( '.slide-background' ) ).forEach( function( backgroundv, v ) {","","\t\t\t\t\tbackgroundv.classList.remove( 'past' );","\t\t\t\t\tbackgroundv.classList.remove( 'present' );","\t\t\t\t\tbackgroundv.classList.remove( 'future' );","","\t\t\t\t\tif( v < indexv ) {","\t\t\t\t\t\tbackgroundv.classList.add( 'past' );","\t\t\t\t\t}","\t\t\t\t\telse if ( v > indexv ) {","\t\t\t\t\t\tbackgroundv.classList.add( 'future' );","\t\t\t\t\t}","\t\t\t\t\telse {","\t\t\t\t\t\tbackgroundv.classList.add( 'present' );","","\t\t\t\t\t\t// Only if this is the present horizontal and vertical slide","\t\t\t\t\t\tif( h === indexh ) currentBackground = backgroundv;","\t\t\t\t\t}","","\t\t\t\t} );","\t\t\t}","","\t\t} );","","\t\t// Stop any currently playing video background","\t\tif( previousBackground ) {","","\t\t\tvar previousVideo = previousBackground.querySelector( 'video' );","\t\t\tif( previousVideo ) previousVideo.pause();","","\t\t}","","\t\tif( currentBackground ) {","","\t\t\t// Start video playback","\t\t\tvar currentVideo = currentBackground.querySelector( 'video' );","\t\t\tif( currentVideo ) {","\t\t\t\tcurrentVideo.currentTime = 0;","\t\t\t\tcurrentVideo.play();","\t\t\t}","","\t\t\t// Don't transition between identical backgrounds. This","\t\t\t// prevents unwanted flicker.","\t\t\tvar previousBackgroundHash = previousBackground ? previousBackground.getAttribute( 'data-background-hash' ) : null;","\t\t\tvar currentBackgroundHash = currentBackground.getAttribute( 'data-background-hash' );","\t\t\tif( currentBackgroundHash && currentBackgroundHash === previousBackgroundHash && currentBackground !== previousBackground ) {","\t\t\t\tdom.background.classList.add( 'no-transition' );","\t\t\t}","","\t\t\tpreviousBackground = currentBackground;","","\t\t}","","\t\t// If there's a background brightness flag for this slide,","\t\t// bubble it to the .reveal container","\t\tif( currentSlide ) {","\t\t\t[ 'has-light-background', 'has-dark-background' ].forEach( function( classToBubble ) {","\t\t\t\tif( currentSlide.classList.contains( classToBubble ) ) {","\t\t\t\t\tdom.wrapper.classList.add( classToBubble );","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\tdom.wrapper.classList.remove( classToBubble );","\t\t\t\t}","\t\t\t} );","\t\t}","","\t\t// Allow the first background to apply without transition","\t\tsetTimeout( function() {","\t\t\tdom.background.classList.remove( 'no-transition' );","\t\t}, 1 );","","\t}","","\t/**","\t * Updates the position of the parallax background based","\t * on the current slide index.","\t */","\tfunction updateParallax() {","","\t\tif( config.parallaxBackgroundImage ) {","","\t\t\tvar horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),","\t\t\t\tverticalSlides = dom.wrapper.querySelectorAll( VERTICAL_SLIDES_SELECTOR );","","\t\t\tvar backgroundSize = dom.background.style.backgroundSize.split( ' ' ),","\t\t\t\tbackgroundWidth, backgroundHeight;","","\t\t\tif( backgroundSize.length === 1 ) {","\t\t\t\tbackgroundWidth = backgroundHeight = parseInt( backgroundSize[0], 10 );","\t\t\t}","\t\t\telse {","\t\t\t\tbackgroundWidth = parseInt( backgroundSize[0], 10 );","\t\t\t\tbackgroundHeight = parseInt( backgroundSize[1], 10 );","\t\t\t}","","\t\t\tvar slideWidth = dom.background.offsetWidth;","\t\t\tvar horizontalSlideCount = horizontalSlides.length;","\t\t\tvar horizontalOffset = -( backgroundWidth - slideWidth ) / ( horizontalSlideCount-1 ) * indexh;","","\t\t\tvar slideHeight = dom.background.offsetHeight;","\t\t\tvar verticalSlideCount = verticalSlides.length;","\t\t\tvar verticalOffset = verticalSlideCount > 1 ? -( backgroundHeight - slideHeight ) / ( verticalSlideCount-1 ) * indexv : 0;","","\t\t\tdom.background.style.backgroundPosition = horizontalOffset + 'px ' + verticalOffset + 'px';","","\t\t}","","\t}","","\t/**","\t * Called when the given slide is within the configured view","\t * distance. Shows the slide element and loads any content","\t * that is set to load lazily (data-src).","\t */","\tfunction showSlide( slide ) {","","\t\t// Show the slide element","\t\tslide.style.display = 'block';","","\t\t// Media elements with data-src attributes","\t\ttoArray( slide.querySelectorAll( 'img[data-src], video[data-src], audio[data-src], iframe[data-src]' ) ).forEach( function( element ) {","\t\t\telement.setAttribute( 'src', element.getAttribute( 'data-src' ) );","\t\t\telement.removeAttribute( 'data-src' );","\t\t} );","","\t\t// Media elements with <source> children","\t\ttoArray( slide.querySelectorAll( 'video, audio' ) ).forEach( function( media ) {","\t\t\tvar sources = 0;","","\t\t\ttoArray( media.querySelectorAll( 'source[data-src]' ) ).forEach( function( source ) {","\t\t\t\tsource.setAttribute( 'src', source.getAttribute( 'data-src' ) );","\t\t\t\tsource.removeAttribute( 'data-src' );","\t\t\t\tsources += 1;","\t\t\t} );","","\t\t\t// If we rewrote sources for this video/audio element, we need","\t\t\t// to manually tell it to load from its new origin","\t\t\tif( sources > 0 ) {","\t\t\t\tmedia.load();","\t\t\t}","\t\t} );","","","\t\t// Show the corresponding background element","\t\tvar indices = getIndices( slide );","\t\tvar background = getSlideBackground( indices.h, indices.v );","\t\tif( background ) {","\t\t\tbackground.style.display = 'block';","","\t\t\t// If the background contains media, load it","\t\t\tif( background.hasAttribute( 'data-loaded' ) === false ) {","\t\t\t\tbackground.setAttribute( 'data-loaded', 'true' );","","\t\t\t\tvar backgroundImage = slide.getAttribute( 'data-background-image' ),","\t\t\t\t\tbackgroundVideo = slide.getAttribute( 'data-background-video' ),","\t\t\t\t\tbackgroundIframe = slide.getAttribute( 'data-background-iframe' );","","\t\t\t\t// Images","\t\t\t\tif( backgroundImage ) {","\t\t\t\t\tbackground.style.backgroundImage = 'url('+ backgroundImage +')';","\t\t\t\t}","\t\t\t\t// Videos","\t\t\t\telse if ( backgroundVideo && !isSpeakerNotes() ) {","\t\t\t\t\tvar video = document.createElement( 'video' );","","\t\t\t\t\t// Support comma separated lists of video sources","\t\t\t\t\tbackgroundVideo.split( ',' ).forEach( function( source ) {","\t\t\t\t\t\tvideo.innerHTML += '<source src=\"'+ source +'\">';","\t\t\t\t\t} );","","\t\t\t\t\tbackground.appendChild( video );","\t\t\t\t}","\t\t\t\t// Iframes","\t\t\t\telse if ( backgroundIframe ) {","\t\t\t\t\tvar iframe = document.createElement( 'iframe' );","\t\t\t\t\t\tiframe.setAttribute( 'src', backgroundIframe );","\t\t\t\t\t\tiframe.style.width  = '100%';","\t\t\t\t\t\tiframe.style.height = '100%';","\t\t\t\t\t\tiframe.style.maxHeight = '100%';","\t\t\t\t\t\tiframe.style.maxWidth = '100%';","","\t\t\t\t\tbackground.appendChild( iframe );","\t\t\t\t}","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Called when the given slide is moved outside of the","\t * configured view distance.","\t */","\tfunction hideSlide( slide ) {","","\t\t// Hide the slide element","\t\tslide.style.display = 'none';","","\t\t// Hide the corresponding background element","\t\tvar indices = getIndices( slide );","\t\tvar background = getSlideBackground( indices.h, indices.v );","\t\tif( background ) {","\t\t\tbackground.style.display = 'none';","\t\t}","","\t}","","\t/**","\t * Determine what available routes there are for navigation.","\t *","\t * @return {Object} containing four booleans: left/right/up/down","\t */","\tfunction availableRoutes() {","","\t\tvar horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),","\t\t\tverticalSlides = dom.wrapper.querySelectorAll( VERTICAL_SLIDES_SELECTOR );","","\t\tvar routes = {","\t\t\tleft: indexh > 0 || config.loop,","\t\t\tright: indexh < horizontalSlides.length - 1 || config.loop,","\t\t\tup: indexv > 0,","\t\t\tdown: indexv < verticalSlides.length - 1","\t\t};","","\t\t// reverse horizontal controls for rtl","\t\tif( config.rtl ) {","\t\t\tvar left = routes.left;","\t\t\troutes.left = routes.right;","\t\t\troutes.right = left;","\t\t}","","\t\treturn routes;","","\t}","","\t/**","\t * Returns an object describing the available fragment","\t * directions.","\t *","\t * @return {Object} two boolean properties: prev/next","\t */","\tfunction availableFragments() {","","\t\tif( currentSlide && config.fragments ) {","\t\t\tvar fragments = currentSlide.querySelectorAll( '.fragment' );","\t\t\tvar hiddenFragments = currentSlide.querySelectorAll( '.fragment:not(.visible)' );","","\t\t\treturn {","\t\t\t\tprev: fragments.length - hiddenFragments.length > 0,","\t\t\t\tnext: !!hiddenFragments.length","\t\t\t};","\t\t}","\t\telse {","\t\t\treturn { prev: false, next: false };","\t\t}","","\t}","","\t/**","\t * Enforces origin-specific format rules for embedded media.","\t */","\tfunction formatEmbeddedContent() {","","\t\t// YouTube frames must include \"?enablejsapi=1\"","\t\ttoArray( dom.slides.querySelectorAll( 'iframe[src*=\"youtube.com/embed/\"]' ) ).forEach( function( el ) {","\t\t\tvar src = el.getAttribute( 'src' );","\t\t\tif( !/enablejsapi\\=1/gi.test( src ) ) {","\t\t\t\tel.setAttribute( 'src', src + ( !/\\?/.test( src ) ? '?' : '&' ) + 'enablejsapi=1' );","\t\t\t}","\t\t});","","\t\t// Vimeo frames must include \"?api=1\"","\t\ttoArray( dom.slides.querySelectorAll( 'iframe[src*=\"player.vimeo.com/\"]' ) ).forEach( function( el ) {","\t\t\tvar src = el.getAttribute( 'src' );","\t\t\tif( !/api\\=1/gi.test( src ) ) {","\t\t\t\tel.setAttribute( 'src', src + ( !/\\?/.test( src ) ? '?' : '&' ) + 'api=1' );","\t\t\t}","\t\t});","","\t}","","\t/**","\t * Start playback of any embedded content inside of","\t * the targeted slide.","\t */","\tfunction startEmbeddedContent( slide ) {","","\t\tif( slide && !isSpeakerNotes() ) {","\t\t\t// HTML5 media elements","\t\t\ttoArray( slide.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {","\t\t\t\tif( el.hasAttribute( 'data-autoplay' ) ) {","\t\t\t\t\tel.play();","\t\t\t\t}","\t\t\t} );","","\t\t\t// iframe embeds","\t\t\ttoArray( slide.querySelectorAll( 'iframe' ) ).forEach( function( el ) {","\t\t\t\tel.contentWindow.postMessage( 'slide:start', '*' );","\t\t\t});","","\t\t\t// YouTube embeds","\t\t\ttoArray( slide.querySelectorAll( 'iframe[src*=\"youtube.com/embed/\"]' ) ).forEach( function( el ) {","\t\t\t\tif( el.hasAttribute( 'data-autoplay' ) ) {","\t\t\t\t\tel.contentWindow.postMessage( '{\"event\":\"command\",\"func\":\"playVideo\",\"args\":\"\"}', '*' );","\t\t\t\t}","\t\t\t});","","\t\t\t// Vimeo embeds","\t\t\ttoArray( slide.querySelectorAll( 'iframe[src*=\"player.vimeo.com/\"]' ) ).forEach( function( el ) {","\t\t\t\tif( el.hasAttribute( 'data-autoplay' ) ) {","\t\t\t\t\tel.contentWindow.postMessage( '{\"method\":\"play\"}', '*' );","\t\t\t\t}","\t\t\t});","\t\t}","","\t}","","\t/**","\t * Stop playback of any embedded content inside of","\t * the targeted slide.","\t */","\tfunction stopEmbeddedContent( slide ) {","","\t\tif( slide && slide.parentNode ) {","\t\t\t// HTML5 media elements","\t\t\ttoArray( slide.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {","\t\t\t\tif( !el.hasAttribute( 'data-ignore' ) ) {","\t\t\t\t\tel.pause();","\t\t\t\t}","\t\t\t} );","","\t\t\t// iframe embeds","\t\t\ttoArray( slide.querySelectorAll( 'iframe' ) ).forEach( function( el ) {","\t\t\t\tel.contentWindow.postMessage( 'slide:stop', '*' );","\t\t\t});","","\t\t\t// YouTube embeds","\t\t\ttoArray( slide.querySelectorAll( 'iframe[src*=\"youtube.com/embed/\"]' ) ).forEach( function( el ) {","\t\t\t\tif( !el.hasAttribute( 'data-ignore' ) && typeof el.contentWindow.postMessage === 'function' ) {","\t\t\t\t\tel.contentWindow.postMessage( '{\"event\":\"command\",\"func\":\"pauseVideo\",\"args\":\"\"}', '*' );","\t\t\t\t}","\t\t\t});","","\t\t\t// Vimeo embeds","\t\t\ttoArray( slide.querySelectorAll( 'iframe[src*=\"player.vimeo.com/\"]' ) ).forEach( function( el ) {","\t\t\t\tif( !el.hasAttribute( 'data-ignore' ) && typeof el.contentWindow.postMessage === 'function' ) {","\t\t\t\t\tel.contentWindow.postMessage( '{\"method\":\"pause\"}', '*' );","\t\t\t\t}","\t\t\t});","\t\t}","","\t}","","\t/**","\t * Returns a value ranging from 0-1 that represents","\t * how far into the presentation we have navigated.","\t */","\tfunction getProgress() {","","\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );","","\t\t// The number of past and total slides","\t\tvar totalCount = getTotalSlides();","\t\tvar pastCount = 0;","","\t\t// Step through all slides and count the past ones","\t\tmainLoop: for( var i = 0; i < horizontalSlides.length; i++ ) {","","\t\t\tvar horizontalSlide = horizontalSlides[i];","\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );","","\t\t\tfor( var j = 0; j < verticalSlides.length; j++ ) {","","\t\t\t\t// Stop as soon as we arrive at the present","\t\t\t\tif( verticalSlides[j].classList.contains( 'present' ) ) {","\t\t\t\t\tbreak mainLoop;","\t\t\t\t}","","\t\t\t\tpastCount++;","","\t\t\t}","","\t\t\t// Stop as soon as we arrive at the present","\t\t\tif( horizontalSlide.classList.contains( 'present' ) ) {","\t\t\t\tbreak;","\t\t\t}","","\t\t\t// Don't count the wrapping section for vertical slides","\t\t\tif( horizontalSlide.classList.contains( 'stack' ) === false ) {","\t\t\t\tpastCount++;","\t\t\t}","","\t\t}","","\t\tif( currentSlide ) {","","\t\t\tvar allFragments = currentSlide.querySelectorAll( '.fragment' );","","\t\t\t// If there are fragments in the current slide those should be","\t\t\t// accounted for in the progress.","\t\t\tif( allFragments.length > 0 ) {","\t\t\t\tvar visibleFragments = currentSlide.querySelectorAll( '.fragment.visible' );","","\t\t\t\t// This value represents how big a portion of the slide progress","\t\t\t\t// that is made up by its fragments (0-1)","\t\t\t\tvar fragmentWeight = 0.9;","","\t\t\t\t// Add fragment progress to the past slide count","\t\t\t\tpastCount += ( visibleFragments.length / allFragments.length ) * fragmentWeight;","\t\t\t}","","\t\t}","","\t\treturn pastCount / ( totalCount - 1 );","","\t}","","\t/**","\t * Checks if this presentation is running inside of the","\t * speaker notes window.","\t */","\tfunction isSpeakerNotes() {","","\t\treturn !!window.location.search.match( /receiver/gi );","","\t}","","\t/**","\t * Reads the current URL (hash) and navigates accordingly.","\t */","\tfunction readURL() {","","\t\tvar hash = window.location.hash;","","\t\t// Attempt to parse the hash as either an index or name","\t\tvar bits = hash.slice( 2 ).split( '/' ),","\t\t\tname = hash.replace( /#|\\//gi, '' );","","\t\t// If the first bit is invalid and there is a name we can","\t\t// assume that this is a named link","\t\tif( isNaN( parseInt( bits[0], 10 ) ) && name.length ) {","\t\t\tvar element;","","\t\t\t// Ensure the named link is a valid HTML ID attribute","\t\t\tif( /^[a-zA-Z][\\w:.-]*$/.test( name ) ) {","\t\t\t\t// Find the slide with the specified ID","\t\t\t\telement = document.querySelector( '#' + name );","\t\t\t}","","\t\t\tif( element ) {","\t\t\t\t// Find the position of the named slide and navigate to it","\t\t\t\tvar indices = Reveal.getIndices( element );","\t\t\t\tslide( indices.h, indices.v );","\t\t\t}","\t\t\t// If the slide doesn't exist, navigate to the current slide","\t\t\telse {","\t\t\t\tslide( indexh || 0, indexv || 0 );","\t\t\t}","\t\t}","\t\telse {","\t\t\t// Read the index components of the hash","\t\t\tvar h = parseInt( bits[0], 10 ) || 0,","\t\t\t\tv = parseInt( bits[1], 10 ) || 0;","","\t\t\tif( h !== indexh || v !== indexv ) {","\t\t\t\tslide( h, v );","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Updates the page URL (hash) to reflect the current","\t * state.","\t *","\t * @param {Number} delay The time in ms to wait before","\t * writing the hash","\t */","\tfunction writeURL( delay ) {","","\t\tif( config.history ) {","","\t\t\t// Make sure there's never more than one timeout running","\t\t\tclearTimeout( writeURLTimeout );","","\t\t\t// If a delay is specified, timeout this call","\t\t\tif( typeof delay === 'number' ) {","\t\t\t\twriteURLTimeout = setTimeout( writeURL, delay );","\t\t\t}","\t\t\telse if( currentSlide ) {","\t\t\t\tvar url = '/';","","\t\t\t\t// Attempt to create a named link based on the slide's ID","\t\t\t\tvar id = currentSlide.getAttribute( 'id' );","\t\t\t\tif( id ) {","\t\t\t\t\tid = id.toLowerCase();","\t\t\t\t\tid = id.replace( /[^a-zA-Z0-9\\-\\_\\:\\.]/g, '' );","\t\t\t\t}","","\t\t\t\t// If the current slide has an ID, use that as a named link","\t\t\t\tif( typeof id === 'string' && id.length ) {","\t\t\t\t\turl = '/' + id;","\t\t\t\t}","\t\t\t\t// Otherwise use the /h/v index","\t\t\t\telse {","\t\t\t\t\tif( indexh > 0 || indexv > 0 ) url += indexh;","\t\t\t\t\tif( indexv > 0 ) url += '/' + indexv;","\t\t\t\t}","","\t\t\t\twindow.location.hash = url;","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Retrieves the h/v location of the current, or specified,","\t * slide.","\t *","\t * @param {HTMLElement} slide If specified, the returned","\t * index will be for this slide rather than the currently","\t * active one","\t *","\t * @return {Object} { h: <int>, v: <int>, f: <int> }","\t */","\tfunction getIndices( slide ) {","","\t\t// By default, return the current indices","\t\tvar h = indexh,","\t\t\tv = indexv,","\t\t\tf;","","\t\t// If a slide is specified, return the indices of that slide","\t\tif( slide ) {","\t\t\tvar isVertical = isVerticalSlide( slide );","\t\t\tvar slideh = isVertical ? slide.parentNode : slide;","","\t\t\t// Select all horizontal slides","\t\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );","","\t\t\t// Now that we know which the horizontal slide is, get its index","\t\t\th = Math.max( horizontalSlides.indexOf( slideh ), 0 );","","\t\t\t// Assume we're not vertical","\t\t\tv = undefined;","","\t\t\t// If this is a vertical slide, grab the vertical index","\t\t\tif( isVertical ) {","\t\t\t\tv = Math.max( toArray( slide.parentNode.querySelectorAll( 'section' ) ).indexOf( slide ), 0 );","\t\t\t}","\t\t}","","\t\tif( !slide && currentSlide ) {","\t\t\tvar hasFragments = currentSlide.querySelectorAll( '.fragment' ).length > 0;","\t\t\tif( hasFragments ) {","\t\t\t\tvar currentFragment = currentSlide.querySelector( '.current-fragment' );","\t\t\t\tif( currentFragment && currentFragment.hasAttribute( 'data-fragment-index' ) ) {","\t\t\t\t\tf = parseInt( currentFragment.getAttribute( 'data-fragment-index' ), 10 );","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\tf = currentSlide.querySelectorAll( '.fragment.visible' ).length - 1;","\t\t\t\t}","\t\t\t}","\t\t}","","\t\treturn { h: h, v: v, f: f };","","\t}","","\t/**","\t * Retrieves the total number of slides in this presentation.","\t */","\tfunction getTotalSlides() {","","\t\treturn dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ':not(.stack)' ).length;","","\t}","","\t/**","\t * Returns the slide element matching the specified index.","\t */","\tfunction getSlide( x, y ) {","","\t\tvar horizontalSlide = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR )[ x ];","\t\tvar verticalSlides = horizontalSlide && horizontalSlide.querySelectorAll( 'section' );","","\t\tif( verticalSlides && verticalSlides.length && typeof y === 'number' ) {","\t\t\treturn verticalSlides ? verticalSlides[ y ] : undefined;","\t\t}","","\t\treturn horizontalSlide;","","\t}","","\t/**","\t * Returns the background element for the given slide.","\t * All slides, even the ones with no background properties","\t * defined, have a background element so as long as the","\t * index is valid an element will be returned.","\t */","\tfunction getSlideBackground( x, y ) {","","\t\t// When printing to PDF the slide backgrounds are nested","\t\t// inside of the slides","\t\tif( isPrintingPDF() ) {","\t\t\tvar slide = getSlide( x, y );","\t\t\tif( slide ) {","\t\t\t\tvar background = slide.querySelector( '.slide-background' );","\t\t\t\tif( background && background.parentNode === slide ) {","\t\t\t\t\treturn background;","\t\t\t\t}","\t\t\t}","","\t\t\treturn undefined;","\t\t}","","\t\tvar horizontalBackground = dom.wrapper.querySelectorAll( '.backgrounds>.slide-background' )[ x ];","\t\tvar verticalBackgrounds = horizontalBackground && horizontalBackground.querySelectorAll( '.slide-background' );","","\t\tif( verticalBackgrounds && verticalBackgrounds.length && typeof y === 'number' ) {","\t\t\treturn verticalBackgrounds ? verticalBackgrounds[ y ] : undefined;","\t\t}","","\t\treturn horizontalBackground;","","\t}","","\t/**","\t * Retrieves the current state of the presentation as","\t * an object. This state can then be restored at any","\t * time.","\t */","\tfunction getState() {","","\t\tvar indices = getIndices();","","\t\treturn {","\t\t\tindexh: indices.h,","\t\t\tindexv: indices.v,","\t\t\tindexf: indices.f,","\t\t\tpaused: isPaused(),","\t\t\toverview: isOverview()","\t\t};","","\t}","","\t/**","\t * Restores the presentation to the given state.","\t *","\t * @param {Object} state As generated by getState()","\t */","\tfunction setState( state ) {","","\t\tif( typeof state === 'object' ) {","\t\t\tslide( deserialize( state.indexh ), deserialize( state.indexv ), deserialize( state.indexf ) );","","\t\t\tvar pausedFlag = deserialize( state.paused ),","\t\t\t\toverviewFlag = deserialize( state.overview );","","\t\t\tif( typeof pausedFlag === 'boolean' && pausedFlag !== isPaused() ) {","\t\t\t\ttogglePause( pausedFlag );","\t\t\t}","","\t\t\tif( typeof overviewFlag === 'boolean' && overviewFlag !== isOverview() ) {","\t\t\t\ttoggleOverview( overviewFlag );","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Return a sorted fragments list, ordered by an increasing","\t * \"data-fragment-index\" attribute.","\t *","\t * Fragments will be revealed in the order that they are returned by","\t * this function, so you can use the index attributes to control the","\t * order of fragment appearance.","\t *","\t * To maintain a sensible default fragment order, fragments are presumed","\t * to be passed in document order. This function adds a \"fragment-index\"","\t * attribute to each node if such an attribute is not already present,","\t * and sets that attribute to an integer value which is the position of","\t * the fragment within the fragments list.","\t */","\tfunction sortFragments( fragments ) {","","\t\tfragments = toArray( fragments );","","\t\tvar ordered = [],","\t\t\tunordered = [],","\t\t\tsorted = [];","","\t\t// Group ordered and unordered elements","\t\tfragments.forEach( function( fragment, i ) {","\t\t\tif( fragment.hasAttribute( 'data-fragment-index' ) ) {","\t\t\t\tvar index = parseInt( fragment.getAttribute( 'data-fragment-index' ), 10 );","","\t\t\t\tif( !ordered[index] ) {","\t\t\t\t\tordered[index] = [];","\t\t\t\t}","","\t\t\t\tordered[index].push( fragment );","\t\t\t}","\t\t\telse {","\t\t\t\tunordered.push( [ fragment ] );","\t\t\t}","\t\t} );","","\t\t// Append fragments without explicit indices in their","\t\t// DOM order","\t\tordered = ordered.concat( unordered );","","\t\t// Manually count the index up per group to ensure there","\t\t// are no gaps","\t\tvar index = 0;","","\t\t// Push all fragments in their sorted order to an array,","\t\t// this flattens the groups","\t\tordered.forEach( function( group ) {","\t\t\tgroup.forEach( function( fragment ) {","\t\t\t\tsorted.push( fragment );","\t\t\t\tfragment.setAttribute( 'data-fragment-index', index );","\t\t\t} );","","\t\t\tindex ++;","\t\t} );","","\t\treturn sorted;","","\t}","","\t/**","\t * Navigate to the specified slide fragment.","\t *","\t * @param {Number} index The index of the fragment that","\t * should be shown, -1 means all are invisible","\t * @param {Number} offset Integer offset to apply to the","\t * fragment index","\t *","\t * @return {Boolean} true if a change was made in any","\t * fragments visibility as part of this call","\t */","\tfunction navigateFragment( index, offset ) {","","\t\tif( currentSlide && config.fragments ) {","","\t\t\tvar fragments = sortFragments( currentSlide.querySelectorAll( '.fragment' ) );","\t\t\tif( fragments.length ) {","","\t\t\t\t// If no index is specified, find the current","\t\t\t\tif( typeof index !== 'number' ) {","\t\t\t\t\tvar lastVisibleFragment = sortFragments( currentSlide.querySelectorAll( '.fragment.visible' ) ).pop();","","\t\t\t\t\tif( lastVisibleFragment ) {","\t\t\t\t\t\tindex = parseInt( lastVisibleFragment.getAttribute( 'data-fragment-index' ) || 0, 10 );","\t\t\t\t\t}","\t\t\t\t\telse {","\t\t\t\t\t\tindex = -1;","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// If an offset is specified, apply it to the index","\t\t\t\tif( typeof offset === 'number' ) {","\t\t\t\t\tindex += offset;","\t\t\t\t}","","\t\t\t\tvar fragmentsShown = [],","\t\t\t\t\tfragmentsHidden = [];","","\t\t\t\ttoArray( fragments ).forEach( function( element, i ) {","","\t\t\t\t\tif( element.hasAttribute( 'data-fragment-index' ) ) {","\t\t\t\t\t\ti = parseInt( element.getAttribute( 'data-fragment-index' ), 10 );","\t\t\t\t\t}","","\t\t\t\t\t// Visible fragments","\t\t\t\t\tif( i <= index ) {","\t\t\t\t\t\tif( !element.classList.contains( 'visible' ) ) fragmentsShown.push( element );","\t\t\t\t\t\telement.classList.add( 'visible' );","\t\t\t\t\t\telement.classList.remove( 'current-fragment' );","","\t\t\t\t\t\t// Announce the fragments one by one to the Screen Reader","\t\t\t\t\t\tdom.statusDiv.textContent = element.textContent;","","\t\t\t\t\t\tif( i === index ) {","\t\t\t\t\t\t\telement.classList.add( 'current-fragment' );","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\t// Hidden fragments","\t\t\t\t\telse {","\t\t\t\t\t\tif( element.classList.contains( 'visible' ) ) fragmentsHidden.push( element );","\t\t\t\t\t\telement.classList.remove( 'visible' );","\t\t\t\t\t\telement.classList.remove( 'current-fragment' );","\t\t\t\t\t}","","","\t\t\t\t} );","","\t\t\t\tif( fragmentsHidden.length ) {","\t\t\t\t\tdispatchEvent( 'fragmenthidden', { fragment: fragmentsHidden[0], fragments: fragmentsHidden } );","\t\t\t\t}","","\t\t\t\tif( fragmentsShown.length ) {","\t\t\t\t\tdispatchEvent( 'fragmentshown', { fragment: fragmentsShown[0], fragments: fragmentsShown } );","\t\t\t\t}","","\t\t\t\tupdateControls();","\t\t\t\tupdateProgress();","","\t\t\t\treturn !!( fragmentsShown.length || fragmentsHidden.length );","","\t\t\t}","","\t\t}","","\t\treturn false;","","\t}","","\t/**","\t * Navigate to the next slide fragment.","\t *","\t * @return {Boolean} true if there was a next fragment,","\t * false otherwise","\t */","\tfunction nextFragment() {","","\t\treturn navigateFragment( null, 1 );","","\t}","","\t/**","\t * Navigate to the previous slide fragment.","\t *","\t * @return {Boolean} true if there was a previous fragment,","\t * false otherwise","\t */","\tfunction previousFragment() {","","\t\treturn navigateFragment( null, -1 );","","\t}","","\t/**","\t * Cues a new automated slide if enabled in the config.","\t */","\tfunction cueAutoSlide() {","","\t\tcancelAutoSlide();","","\t\tif( currentSlide ) {","","\t\t\tvar currentFragment = currentSlide.querySelector( '.current-fragment' );","","\t\t\tvar fragmentAutoSlide = currentFragment ? currentFragment.getAttribute( 'data-autoslide' ) : null;","\t\t\tvar parentAutoSlide = currentSlide.parentNode ? currentSlide.parentNode.getAttribute( 'data-autoslide' ) : null;","\t\t\tvar slideAutoSlide = currentSlide.getAttribute( 'data-autoslide' );","","\t\t\t// Pick value in the following priority order:","\t\t\t// 1. Current fragment's data-autoslide","\t\t\t// 2. Current slide's data-autoslide","\t\t\t// 3. Parent slide's data-autoslide","\t\t\t// 4. Global autoSlide setting","\t\t\tif( fragmentAutoSlide ) {","\t\t\t\tautoSlide = parseInt( fragmentAutoSlide, 10 );","\t\t\t}","\t\t\telse if( slideAutoSlide ) {","\t\t\t\tautoSlide = parseInt( slideAutoSlide, 10 );","\t\t\t}","\t\t\telse if( parentAutoSlide ) {","\t\t\t\tautoSlide = parseInt( parentAutoSlide, 10 );","\t\t\t}","\t\t\telse {","\t\t\t\tautoSlide = config.autoSlide;","\t\t\t}","","\t\t\t// If there are media elements with data-autoplay,","\t\t\t// automatically set the autoSlide duration to the","\t\t\t// length of that media","\t\t\ttoArray( currentSlide.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {","\t\t\t\tif( el.hasAttribute( 'data-autoplay' ) ) {","\t\t\t\t\tif( autoSlide && el.duration * 1000 > autoSlide ) {","\t\t\t\t\t\tautoSlide = ( el.duration * 1000 ) + 1000;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t} );","","\t\t\t// Cue the next auto-slide if:","\t\t\t// - There is an autoSlide value","\t\t\t// - Auto-sliding isn't paused by the user","\t\t\t// - The presentation isn't paused","\t\t\t// - The overview isn't active","\t\t\t// - The presentation isn't over","\t\t\tif( autoSlide && !autoSlidePaused && !isPaused() && !isOverview() && ( !Reveal.isLastSlide() || availableFragments().next || config.loop === true ) ) {","\t\t\t\tautoSlideTimeout = setTimeout( navigateNext, autoSlide );","\t\t\t\tautoSlideStartTime = Date.now();","\t\t\t}","","\t\t\tif( autoSlidePlayer ) {","\t\t\t\tautoSlidePlayer.setPlaying( autoSlideTimeout !== -1 );","\t\t\t}","","\t\t}","","\t}","","\t/**","\t * Cancels any ongoing request to auto-slide.","\t */","\tfunction cancelAutoSlide() {","","\t\tclearTimeout( autoSlideTimeout );","\t\tautoSlideTimeout = -1;","","\t}","","\tfunction pauseAutoSlide() {","","\t\tif( autoSlide && !autoSlidePaused ) {","\t\t\tautoSlidePaused = true;","\t\t\tdispatchEvent( 'autoslidepaused' );","\t\t\tclearTimeout( autoSlideTimeout );","","\t\t\tif( autoSlidePlayer ) {","\t\t\t\tautoSlidePlayer.setPlaying( false );","\t\t\t}","\t\t}","","\t}","","\tfunction resumeAutoSlide() {","","\t\tif( autoSlide && autoSlidePaused ) {","\t\t\tautoSlidePaused = false;","\t\t\tdispatchEvent( 'autoslideresumed' );","\t\t\tcueAutoSlide();","\t\t}","","\t}","","\tfunction navigateLeft() {","","\t\t// Reverse for RTL","\t\tif( config.rtl ) {","\t\t\tif( ( isOverview() || nextFragment() === false ) && availableRoutes().left ) {","\t\t\t\tslide( indexh + 1 );","\t\t\t}","\t\t}","\t\t// Normal navigation","\t\telse if( ( isOverview() || previousFragment() === false ) && availableRoutes().left ) {","\t\t\tslide( indexh - 1 );","\t\t}","","\t}","","\tfunction navigateRight() {","","\t\t// Reverse for RTL","\t\tif( config.rtl ) {","\t\t\tif( ( isOverview() || previousFragment() === false ) && availableRoutes().right ) {","\t\t\t\tslide( indexh - 1 );","\t\t\t}","\t\t}","\t\t// Normal navigation","\t\telse if( ( isOverview() || nextFragment() === false ) && availableRoutes().right ) {","\t\t\tslide( indexh + 1 );","\t\t}","","\t}","","\tfunction navigateUp() {","","\t\t// Prioritize hiding fragments","\t\tif( ( isOverview() || previousFragment() === false ) && availableRoutes().up ) {","\t\t\tslide( indexh, indexv - 1 );","\t\t}","","\t}","","\tfunction navigateDown() {","","\t\t// Prioritize revealing fragments","\t\tif( ( isOverview() || nextFragment() === false ) && availableRoutes().down ) {","\t\t\tslide( indexh, indexv + 1 );","\t\t}","","\t}","","\t/**","\t * Navigates backwards, prioritized in the following order:","\t * 1) Previous fragment","\t * 2) Previous vertical slide","\t * 3) Previous horizontal slide","\t */","\tfunction navigatePrev() {","","\t\t// Prioritize revealing fragments","\t\tif( previousFragment() === false ) {","\t\t\tif( availableRoutes().up ) {","\t\t\t\tnavigateUp();","\t\t\t}","\t\t\telse {","\t\t\t\t// Fetch the previous horizontal slide, if there is one","\t\t\t\tvar previousSlide;","","\t\t\t\tif( config.rtl ) {","\t\t\t\t\tpreviousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.future' ) ).pop();","\t\t\t\t}","\t\t\t\telse {","\t\t\t\t\tpreviousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.past' ) ).pop();","\t\t\t\t}","","\t\t\t\tif( previousSlide ) {","\t\t\t\t\tvar v = ( previousSlide.querySelectorAll( 'section' ).length - 1 ) || undefined;","\t\t\t\t\tvar h = indexh - 1;","\t\t\t\t\tslide( h, v );","\t\t\t\t}","\t\t\t}","\t\t}","","\t}","","\t/**","\t * The reverse of #navigatePrev().","\t */","\tfunction navigateNext() {","","\t\t// Prioritize revealing fragments","\t\tif( nextFragment() === false ) {","\t\t\tif( availableRoutes().down ) {","\t\t\t\tnavigateDown();","\t\t\t}","\t\t\telse if( config.rtl ) {","\t\t\t\tnavigateLeft();","\t\t\t}","\t\t\telse {","\t\t\t\tnavigateRight();","\t\t\t}","\t\t}","","\t\t// If auto-sliding is enabled we need to cue up","\t\t// another timeout","\t\tcueAutoSlide();","","\t}","","","\t// --------------------------------------------------------------------//","\t// ----------------------------- EVENTS -------------------------------//","\t// --------------------------------------------------------------------//","","\t/**","\t * Called by all event handlers that are based on user","\t * input.","\t */","\tfunction onUserInput( event ) {","","\t\tif( config.autoSlideStoppable ) {","\t\t\tpauseAutoSlide();","\t\t}","","\t}","","\t/**","\t * Handler for the document level 'keypress' event.","\t */","\tfunction onDocumentKeyPress( event ) {","","\t\t// Check if the pressed key is question mark","\t\tif( event.shiftKey && event.charCode === 63 ) {","\t\t\tif( dom.overlay ) {","\t\t\t\tcloseOverlay();","\t\t\t}","\t\t\telse {","\t\t\t\tshowHelp( true );","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Handler for the document level 'keydown' event.","\t */","\tfunction onDocumentKeyDown( event ) {","","\t\t// If there's a condition specified and it returns false,","\t\t// ignore this event","\t\tif( typeof config.keyboardCondition === 'function' && config.keyboardCondition() === false ) {","\t\t\treturn true;","\t\t}","","\t\t// Remember if auto-sliding was paused so we can toggle it","\t\tvar autoSlideWasPaused = autoSlidePaused;","","\t\tonUserInput( event );","","\t\t// Check if there's a focused element that could be using","\t\t// the keyboard","\t\tvar activeElementIsCE = document.activeElement && document.activeElement.contentEditable !== 'inherit';","\t\tvar activeElementIsInput = document.activeElement && document.activeElement.tagName && /input|textarea/i.test( document.activeElement.tagName );","","\t\t// Disregard the event if there's a focused element or a","\t\t// keyboard modifier key is present","\t\tif( activeElementIsCE || activeElementIsInput || (event.shiftKey && event.keyCode !== 32) || event.altKey || event.ctrlKey || event.metaKey ) return;","","\t\t// While paused only allow \"unpausing\" keyboard events (b and .)","\t\tif( isPaused() && [66,190,191].indexOf( event.keyCode ) === -1 ) {","\t\t\treturn false;","\t\t}","","\t\tvar triggered = false;","","\t\t// 1. User defined key bindings","\t\tif( typeof config.keyboard === 'object' ) {","","\t\t\tfor( var key in config.keyboard ) {","","\t\t\t\t// Check if this binding matches the pressed key","\t\t\t\tif( parseInt( key, 10 ) === event.keyCode ) {","","\t\t\t\t\tvar value = config.keyboard[ key ];","","\t\t\t\t\t// Callback function","\t\t\t\t\tif( typeof value === 'function' ) {","\t\t\t\t\t\tvalue.apply( null, [ event ] );","\t\t\t\t\t}","\t\t\t\t\t// String shortcuts to reveal.js API","\t\t\t\t\telse if( typeof value === 'string' && typeof Reveal[ value ] === 'function' ) {","\t\t\t\t\t\tReveal[ value ].call();","\t\t\t\t\t}","","\t\t\t\t\ttriggered = true;","","\t\t\t\t}","","\t\t\t}","","\t\t}","","\t\t// 2. System defined key bindings","\t\tif( triggered === false ) {","","\t\t\t// Assume true and try to prove false","\t\t\ttriggered = true;","","\t\t\tswitch( event.keyCode ) {","\t\t\t\t// p, page up","\t\t\t\tcase 80: case 33: navigatePrev(); break;","\t\t\t\t// n, page down","\t\t\t\tcase 78: case 34: navigateNext(); break;","\t\t\t\t// h, left","\t\t\t\tcase 72: case 37: navigateLeft(); break;","\t\t\t\t// l, right","\t\t\t\tcase 76: case 39: navigateRight(); break;","\t\t\t\t// k, up","\t\t\t\tcase 75: case 38: navigateUp(); break;","\t\t\t\t// j, down","\t\t\t\tcase 74: case 40: navigateDown(); break;","\t\t\t\t// home","\t\t\t\tcase 36: slide( 0 ); break;","\t\t\t\t// end","\t\t\t\tcase 35: slide( Number.MAX_VALUE ); break;","\t\t\t\t// space","\t\t\t\tcase 32: isOverview() ? deactivateOverview() : event.shiftKey ? navigatePrev() : navigateNext(); break;","\t\t\t\t// return","\t\t\t\tcase 13: isOverview() ? deactivateOverview() : triggered = false; break;","\t\t\t\t// two-spot, semicolon, b, period, Logitech presenter tools \"black screen\" button","\t\t\t\tcase 58: case 59: case 66: case 190: case 191: togglePause(); break;","\t\t\t\t// f","\t\t\t\tcase 70: enterFullscreen(); break;","\t\t\t\t// a","\t\t\t\tcase 65: if ( config.autoSlideStoppable ) toggleAutoSlide( autoSlideWasPaused ); break;","\t\t\t\tdefault:","\t\t\t\t\ttriggered = false;","\t\t\t}","","\t\t}","","\t\t// If the input resulted in a triggered action we should prevent","\t\t// the browsers default behavior","\t\tif( triggered ) {","\t\t\tevent.preventDefault && event.preventDefault();","\t\t}","\t\t// ESC or O key","\t\telse if ( ( event.keyCode === 27 || event.keyCode === 79 ) && features.transforms3d ) {","\t\t\tif( dom.overlay ) {","\t\t\t\tcloseOverlay();","\t\t\t}","\t\t\telse {","\t\t\t\ttoggleOverview();","\t\t\t}","","\t\t\tevent.preventDefault && event.preventDefault();","\t\t}","","\t\t// If auto-sliding is enabled we need to cue up","\t\t// another timeout","\t\tcueAutoSlide();","","\t}","","\t/**","\t * Handler for the 'touchstart' event, enables support for","\t * swipe and pinch gestures.","\t */","\tfunction onTouchStart( event ) {","","\t\ttouch.startX = event.touches[0].clientX;","\t\ttouch.startY = event.touches[0].clientY;","\t\ttouch.startCount = event.touches.length;","","\t\t// If there's two touches we need to memorize the distance","\t\t// between those two points to detect pinching","\t\tif( event.touches.length === 2 && config.overview ) {","\t\t\ttouch.startSpan = distanceBetween( {","\t\t\t\tx: event.touches[1].clientX,","\t\t\t\ty: event.touches[1].clientY","\t\t\t}, {","\t\t\t\tx: touch.startX,","\t\t\t\ty: touch.startY","\t\t\t} );","\t\t}","","\t}","","\t/**","\t * Handler for the 'touchmove' event.","\t */","\tfunction onTouchMove( event ) {","","\t\t// Each touch should only trigger one action","\t\tif( !touch.captured ) {","\t\t\tonUserInput( event );","","\t\t\tvar currentX = event.touches[0].clientX;","\t\t\tvar currentY = event.touches[0].clientY;","","\t\t\t// If the touch started with two points and still has","\t\t\t// two active touches; test for the pinch gesture","\t\t\tif( event.touches.length === 2 && touch.startCount === 2 && config.overview ) {","","\t\t\t\t// The current distance in pixels between the two touch points","\t\t\t\tvar currentSpan = distanceBetween( {","\t\t\t\t\tx: event.touches[1].clientX,","\t\t\t\t\ty: event.touches[1].clientY","\t\t\t\t}, {","\t\t\t\t\tx: touch.startX,","\t\t\t\t\ty: touch.startY","\t\t\t\t} );","","\t\t\t\t// If the span is larger than the desire amount we've got","\t\t\t\t// ourselves a pinch","\t\t\t\tif( Math.abs( touch.startSpan - currentSpan ) > touch.threshold ) {","\t\t\t\t\ttouch.captured = true;","","\t\t\t\t\tif( currentSpan < touch.startSpan ) {","\t\t\t\t\t\tactivateOverview();","\t\t\t\t\t}","\t\t\t\t\telse {","\t\t\t\t\t\tdeactivateOverview();","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\tevent.preventDefault();","","\t\t\t}","\t\t\t// There was only one touch point, look for a swipe","\t\t\telse if( event.touches.length === 1 && touch.startCount !== 2 ) {","","\t\t\t\tvar deltaX = currentX - touch.startX,","\t\t\t\t\tdeltaY = currentY - touch.startY;","","\t\t\t\tif( deltaX > touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {","\t\t\t\t\ttouch.captured = true;","\t\t\t\t\tnavigateLeft();","\t\t\t\t}","\t\t\t\telse if( deltaX < -touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {","\t\t\t\t\ttouch.captured = true;","\t\t\t\t\tnavigateRight();","\t\t\t\t}","\t\t\t\telse if( deltaY > touch.threshold ) {","\t\t\t\t\ttouch.captured = true;","\t\t\t\t\tnavigateUp();","\t\t\t\t}","\t\t\t\telse if( deltaY < -touch.threshold ) {","\t\t\t\t\ttouch.captured = true;","\t\t\t\t\tnavigateDown();","\t\t\t\t}","","\t\t\t\t// If we're embedded, only block touch events if they have","\t\t\t\t// triggered an action","\t\t\t\tif( config.embedded ) {","\t\t\t\t\tif( touch.captured || isVerticalSlide( currentSlide ) ) {","\t\t\t\t\t\tevent.preventDefault();","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t// Not embedded? Block them all to avoid needless tossing","\t\t\t\t// around of the viewport in iOS","\t\t\t\telse {","\t\t\t\t\tevent.preventDefault();","\t\t\t\t}","","\t\t\t}","\t\t}","\t\t// There's a bug with swiping on some Android devices unless","\t\t// the default action is always prevented","\t\telse if( navigator.userAgent.match( /android/gi ) ) {","\t\t\tevent.preventDefault();","\t\t}","","\t}","","\t/**","\t * Handler for the 'touchend' event.","\t */","\tfunction onTouchEnd( event ) {","","\t\ttouch.captured = false;","","\t}","","\t/**","\t * Convert pointer down to touch start.","\t */","\tfunction onPointerDown( event ) {","","\t\tif( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === \"touch\" ) {","\t\t\tevent.touches = [{ clientX: event.clientX, clientY: event.clientY }];","\t\t\tonTouchStart( event );","\t\t}","","\t}","","\t/**","\t * Convert pointer move to touch move.","\t */","\tfunction onPointerMove( event ) {","","\t\tif( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === \"touch\" )  {","\t\t\tevent.touches = [{ clientX: event.clientX, clientY: event.clientY }];","\t\t\tonTouchMove( event );","\t\t}","","\t}","","\t/**","\t * Convert pointer up to touch end.","\t */","\tfunction onPointerUp( event ) {","","\t\tif( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === \"touch\" )  {","\t\t\tevent.touches = [{ clientX: event.clientX, clientY: event.clientY }];","\t\t\tonTouchEnd( event );","\t\t}","","\t}","","\t/**","\t * Handles mouse wheel scrolling, throttled to avoid skipping","\t * multiple slides.","\t */","\tfunction onDocumentMouseScroll( event ) {","","\t\tif( Date.now() - lastMouseWheelStep > 600 ) {","","\t\t\tlastMouseWheelStep = Date.now();","","\t\t\tvar delta = event.detail || -event.wheelDelta;","\t\t\tif( delta > 0 ) {","\t\t\t\tnavigateNext();","\t\t\t}","\t\t\telse {","\t\t\t\tnavigatePrev();","\t\t\t}","","\t\t}","","\t}","","\t/**","\t * Clicking on the progress bar results in a navigation to the","\t * closest approximate horizontal slide using this equation:","\t *","\t * ( clickX / presentationWidth ) * numberOfSlides","\t */","\tfunction onProgressClicked( event ) {","","\t\tonUserInput( event );","","\t\tevent.preventDefault();","","\t\tvar slidesTotal = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).length;","\t\tvar slideIndex = Math.floor( ( event.clientX / dom.wrapper.offsetWidth ) * slidesTotal );","","\t\tslide( slideIndex );","","\t}","","\t/**","\t * Event handler for navigation control buttons.","\t */","\tfunction onNavigateLeftClicked( event ) { event.preventDefault(); onUserInput(); navigateLeft(); }","\tfunction onNavigateRightClicked( event ) { event.preventDefault(); onUserInput(); navigateRight(); }","\tfunction onNavigateUpClicked( event ) { event.preventDefault(); onUserInput(); navigateUp(); }","\tfunction onNavigateDownClicked( event ) { event.preventDefault(); onUserInput(); navigateDown(); }","\tfunction onNavigatePrevClicked( event ) { event.preventDefault(); onUserInput(); navigatePrev(); }","\tfunction onNavigateNextClicked( event ) { event.preventDefault(); onUserInput(); navigateNext(); }","","\t/**","\t * Handler for the window level 'hashchange' event.","\t */","\tfunction onWindowHashChange( event ) {","","\t\treadURL();","","\t}","","\t/**","\t * Handler for the window level 'resize' event.","\t */","\tfunction onWindowResize( event ) {","","\t\tlayout();","","\t}","","\t/**","\t * Handle for the window level 'visibilitychange' event.","\t */","\tfunction onPageVisibilityChange( event ) {","","\t\tvar isHidden =  document.webkitHidden ||","\t\t\t\t\t\tdocument.msHidden ||","\t\t\t\t\t\tdocument.hidden;","","\t\t// If, after clicking a link or similar and we're coming back,","\t\t// focus the document.body to ensure we can use keyboard shortcuts","\t\tif( isHidden === false && document.activeElement !== document.body ) {","\t\t\tdocument.activeElement.blur();","\t\t\tdocument.body.focus();","\t\t}","","\t}","","\t/**","\t * Invoked when a slide is and we're in the overview.","\t */","\tfunction onOverviewSlideClicked( event ) {","","\t\t// TODO There's a bug here where the event listeners are not","\t\t// removed after deactivating the overview.","\t\tif( eventsAreBound && isOverview() ) {","\t\t\tevent.preventDefault();","","\t\t\tvar element = event.target;","","\t\t\twhile( element && !element.nodeName.match( /section/gi ) ) {","\t\t\t\telement = element.parentNode;","\t\t\t}","","\t\t\tif( element && !element.classList.contains( 'disabled' ) ) {","","\t\t\t\tdeactivateOverview();","","\t\t\t\tif( element.nodeName.match( /section/gi ) ) {","\t\t\t\t\tvar h = parseInt( element.getAttribute( 'data-index-h' ), 10 ),","\t\t\t\t\t\tv = parseInt( element.getAttribute( 'data-index-v' ), 10 );","","\t\t\t\t\tslide( h, v );","\t\t\t\t}","","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Handles clicks on links that are set to preview in the","\t * iframe overlay.","\t */","\tfunction onPreviewLinkClicked( event ) {","","\t\tif( event.currentTarget && event.currentTarget.hasAttribute( 'href' ) ) {","\t\t\tvar url = event.currentTarget.getAttribute( 'href' );","\t\t\tif( url ) {","\t\t\t\tshowPreview( url );","\t\t\t\tevent.preventDefault();","\t\t\t}","\t\t}","","\t}","","\t/**","\t * Handles click on the auto-sliding controls element.","\t */","\tfunction onAutoSlidePlayerClick( event ) {","","\t\t// Replay","\t\tif( Reveal.isLastSlide() && config.loop === false ) {","\t\t\tslide( 0, 0 );","\t\t\tresumeAutoSlide();","\t\t}","\t\t// Resume","\t\telse if( autoSlidePaused ) {","\t\t\tresumeAutoSlide();","\t\t}","\t\t// Pause","\t\telse {","\t\t\tpauseAutoSlide();","\t\t}","","\t}","","","\t// --------------------------------------------------------------------//","\t// ------------------------ PLAYBACK COMPONENT ------------------------//","\t// --------------------------------------------------------------------//","","","\t/**","\t * Constructor for the playback component, which displays","\t * play/pause/progress controls.","\t *","\t * @param {HTMLElement} container The component will append","\t * itself to this","\t * @param {Function} progressCheck A method which will be","\t * called frequently to get the current progress on a range","\t * of 0-1","\t */","\tfunction Playback( container, progressCheck ) {","","\t\t// Cosmetics","\t\tthis.diameter = 50;","\t\tthis.thickness = 3;","","\t\t// Flags if we are currently playing","\t\tthis.playing = false;","","\t\t// Current progress on a 0-1 range","\t\tthis.progress = 0;","","\t\t// Used to loop the animation smoothly","\t\tthis.progressOffset = 1;","","\t\tthis.container = container;","\t\tthis.progressCheck = progressCheck;","","\t\tthis.canvas = document.createElement( 'canvas' );","\t\tthis.canvas.className = 'playback';","\t\tthis.canvas.width = this.diameter;","\t\tthis.canvas.height = this.diameter;","\t\tthis.context = this.canvas.getContext( '2d' );","","\t\tthis.container.appendChild( this.canvas );","","\t\tthis.render();","","\t}","","\tPlayback.prototype.setPlaying = function( value ) {","","\t\tvar wasPlaying = this.playing;","","\t\tthis.playing = value;","","\t\t// Start repainting if we weren't already","\t\tif( !wasPlaying && this.playing ) {","\t\t\tthis.animate();","\t\t}","\t\telse {","\t\t\tthis.render();","\t\t}","","\t};","","\tPlayback.prototype.animate = function() {","","\t\tvar progressBefore = this.progress;","","\t\tthis.progress = this.progressCheck();","","\t\t// When we loop, offset the progress so that it eases","\t\t// smoothly rather than immediately resetting","\t\tif( progressBefore > 0.8 && this.progress < 0.2 ) {","\t\t\tthis.progressOffset = this.progress;","\t\t}","","\t\tthis.render();","","\t\tif( this.playing ) {","\t\t\tfeatures.requestAnimationFrameMethod.call( window, this.animate.bind( this ) );","\t\t}","","\t};","","\t/**","\t * Renders the current progress and playback state.","\t */","\tPlayback.prototype.render = function() {","","\t\tvar progress = this.playing ? this.progress : 0,","\t\t\tradius = ( this.diameter / 2 ) - this.thickness,","\t\t\tx = this.diameter / 2,","\t\t\ty = this.diameter / 2,","\t\t\ticonSize = 14;","","\t\t// Ease towards 1","\t\tthis.progressOffset += ( 1 - this.progressOffset ) * 0.1;","","\t\tvar endAngle = ( - Math.PI / 2 ) + ( progress * ( Math.PI * 2 ) );","\t\tvar startAngle = ( - Math.PI / 2 ) + ( this.progressOffset * ( Math.PI * 2 ) );","","\t\tthis.context.save();","\t\tthis.context.clearRect( 0, 0, this.diameter, this.diameter );","","\t\t// Solid background color","\t\tthis.context.beginPath();","\t\tthis.context.arc( x, y, radius + 2, 0, Math.PI * 2, false );","\t\tthis.context.fillStyle = 'rgba( 0, 0, 0, 0.4 )';","\t\tthis.context.fill();","","\t\t// Draw progress track","\t\tthis.context.beginPath();","\t\tthis.context.arc( x, y, radius, 0, Math.PI * 2, false );","\t\tthis.context.lineWidth = this.thickness;","\t\tthis.context.strokeStyle = '#666';","\t\tthis.context.stroke();","","\t\tif( this.playing ) {","\t\t\t// Draw progress on top of track","\t\t\tthis.context.beginPath();","\t\t\tthis.context.arc( x, y, radius, startAngle, endAngle, false );","\t\t\tthis.context.lineWidth = this.thickness;","\t\t\tthis.context.strokeStyle = '#fff';","\t\t\tthis.context.stroke();","\t\t}","","\t\tthis.context.translate( x - ( iconSize / 2 ), y - ( iconSize / 2 ) );","","\t\t// Draw play/pause icons","\t\tif( this.playing ) {","\t\t\tthis.context.fillStyle = '#fff';","\t\t\tthis.context.fillRect( 0, 0, iconSize / 2 - 2, iconSize );","\t\t\tthis.context.fillRect( iconSize / 2 + 2, 0, iconSize / 2 - 2, iconSize );","\t\t}","\t\telse {","\t\t\tthis.context.beginPath();","\t\t\tthis.context.translate( 2, 0 );","\t\t\tthis.context.moveTo( 0, 0 );","\t\t\tthis.context.lineTo( iconSize - 2, iconSize / 2 );","\t\t\tthis.context.lineTo( 0, iconSize );","\t\t\tthis.context.fillStyle = '#fff';","\t\t\tthis.context.fill();","\t\t}","","\t\tthis.context.restore();","","\t};","","\tPlayback.prototype.on = function( type, listener ) {","\t\tthis.canvas.addEventListener( type, listener, false );","\t};","","\tPlayback.prototype.off = function( type, listener ) {","\t\tthis.canvas.removeEventListener( type, listener, false );","\t};","","\tPlayback.prototype.destroy = function() {","","\t\tthis.playing = false;","","\t\tif( this.canvas.parentNode ) {","\t\t\tthis.container.removeChild( this.canvas );","\t\t}","","\t};","","","\t// --------------------------------------------------------------------//","\t// ------------------------------- API --------------------------------//","\t// --------------------------------------------------------------------//","","","\tReveal = {","\t\tinitialize: initialize,","\t\tconfigure: configure,","\t\tsync: sync,","","\t\t// Navigation methods","\t\tslide: slide,","\t\tleft: navigateLeft,","\t\tright: navigateRight,","\t\tup: navigateUp,","\t\tdown: navigateDown,","\t\tprev: navigatePrev,","\t\tnext: navigateNext,","","\t\t// Fragment methods","\t\tnavigateFragment: navigateFragment,","\t\tprevFragment: previousFragment,","\t\tnextFragment: nextFragment,","","\t\t// Deprecated aliases","\t\tnavigateTo: slide,","\t\tnavigateLeft: navigateLeft,","\t\tnavigateRight: navigateRight,","\t\tnavigateUp: navigateUp,","\t\tnavigateDown: navigateDown,","\t\tnavigatePrev: navigatePrev,","\t\tnavigateNext: navigateNext,","","\t\t// Forces an update in slide layout","\t\tlayout: layout,","","\t\t// Returns an object with the available routes as booleans (left/right/top/bottom)","\t\tavailableRoutes: availableRoutes,","","\t\t// Returns an object with the available fragments as booleans (prev/next)","\t\tavailableFragments: availableFragments,","","\t\t// Toggles the overview mode on/off","\t\ttoggleOverview: toggleOverview,","","\t\t// Toggles the \"black screen\" mode on/off","\t\ttogglePause: togglePause,","","\t\t// Toggles the auto slide mode on/off","\t\ttoggleAutoSlide: toggleAutoSlide,","","\t\t// State checks","\t\tisOverview: isOverview,","\t\tisPaused: isPaused,","\t\tisAutoSliding: isAutoSliding,","","\t\t// Adds or removes all internal event listeners (such as keyboard)","\t\taddEventListeners: addEventListeners,","\t\tremoveEventListeners: removeEventListeners,","","\t\t// Facility for persisting and restoring the presentation state","\t\tgetState: getState,","\t\tsetState: setState,","","\t\t// Presentation progress on range of 0-1","\t\tgetProgress: getProgress,","","\t\t// Returns the indices of the current, or specified, slide","\t\tgetIndices: getIndices,","","\t\tgetTotalSlides: getTotalSlides,","","\t\t// Returns the slide element at the specified index","\t\tgetSlide: getSlide,","","\t\t// Returns the slide background element at the specified index","\t\tgetSlideBackground: getSlideBackground,","","\t\t// Returns the previous slide element, may be null","\t\tgetPreviousSlide: function() {","\t\t\treturn previousSlide;","\t\t},","","\t\t// Returns the current slide element","\t\tgetCurrentSlide: function() {","\t\t\treturn currentSlide;","\t\t},","","\t\t// Returns the current scale of the presentation content","\t\tgetScale: function() {","\t\t\treturn scale;","\t\t},","","\t\t// Returns the current configuration object","\t\tgetConfig: function() {","\t\t\treturn config;","\t\t},","","\t\t// Helper method, retrieves query string as a key/value hash","\t\tgetQueryHash: function() {","\t\t\tvar query = {};","","\t\t\tlocation.search.replace( /[A-Z0-9]+?=([\\w\\.%-]*)/gi, function(a) {","\t\t\t\tquery[ a.split( '=' ).shift() ] = a.split( '=' ).pop();","\t\t\t} );","","\t\t\t// Basic deserialization","\t\t\tfor( var i in query ) {","\t\t\t\tvar value = query[ i ];","","\t\t\t\tquery[ i ] = deserialize( unescape( value ) );","\t\t\t}","","\t\t\treturn query;","\t\t},","","\t\t// Returns true if we're currently on the first slide","\t\tisFirstSlide: function() {","\t\t\treturn ( indexh === 0 && indexv === 0 );","\t\t},","","\t\t// Returns true if we're currently on the last slide","\t\tisLastSlide: function() {","\t\t\tif( currentSlide ) {","\t\t\t\t// Does this slide has next a sibling?","\t\t\t\tif( currentSlide.nextElementSibling ) return false;","","\t\t\t\t// If it's vertical, does its parent have a next sibling?","\t\t\t\tif( isVerticalSlide( currentSlide ) && currentSlide.parentNode.nextElementSibling ) return false;","","\t\t\t\treturn true;","\t\t\t}","","\t\t\treturn false;","\t\t},","","\t\t// Checks if reveal.js has been loaded and is ready for use","\t\tisReady: function() {","\t\t\treturn loaded;","\t\t},","","\t\t// Forward event binding to the reveal DOM element","\t\taddEventListener: function( type, listener, useCapture ) {","\t\t\tif( 'addEventListener' in window ) {","\t\t\t\t( dom.wrapper || document.querySelector( '.reveal' ) ).addEventListener( type, listener, useCapture );","\t\t\t}","\t\t},","\t\tremoveEventListener: function( type, listener, useCapture ) {","\t\t\tif( 'addEventListener' in window ) {","\t\t\t\t( dom.wrapper || document.querySelector( '.reveal' ) ).removeEventListener( type, listener, useCapture );","\t\t\t}","\t\t},","","\t\t// Programatically triggers a keyboard event","\t\ttriggerKey: function( keyCode ) {","\t\t\tonDocumentKeyDown( { keyCode: keyCode } );","\t\t}","\t};","","\treturn Reveal;","","}));",""]}]}]]},"ace":{"folds":[],"scrolltop":62299.33469295502,"scrollleft":0,"selection":{"start":{"row":4276,"column":0},"end":{"row":4276,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":355,"state":"start","mode":"ace/mode/javascript"}},"timestamp":1427360078735,"hash":"6d6a10c166cfc4b8d80311fbb07ca7e7b54c016c"}